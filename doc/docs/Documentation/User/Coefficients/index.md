# Coefficients 

This page described how to define and manage coefficients, usefull objects to define physical properties in `SLOTH`. 

Definition of coefficients for `SLOTH` is made with a C++ object of type `Coefficients` that is simply a set of C++ object of type [`Coefficient`](#coefficient).

## __Coefficient description__ {#coefficient}

For SLOTH, a `Coefficient` is a C++ object defined by:

- a [`GlobalQuantity`](../Glossary/index.md,)
- a `SLOTH` C++ enum type `Scheme` (except for constant coefficients) : available values for users are `Scheme::Implicit`, `Scheme::Explicit`, `Scheme::SemiImplicit`. These values are directly linked to the definition of coefficients and their use in `SLOTH` integrators.
- a `SLOTH` C++ type `FunctionCoefficient`.

The `FunctionCoefficient` object is not really managed by the user since `SLOTH` provides interfaces with 

- the C++ Mathematical Expression Toolkit Library [ExprTk](https://www.partow.net/programming/exprtk/),
- the Python library for symbolic mathematics [Sympy](https://docs.sympy.org/latest/index.html).

The instructions for installing these dependencies are provided in a [dedicated page of the user manual](../../../Started/Installation/exprtk_sympy.md).

### __Sympy interface__ {#coef_sympy}

The `Sympy` interface corresponds to a Python script (see the `script/GenerateCoefficient.py` file in the `SLOTH` repository) which automatically generates the expected `FunctionCoefficient`-type classes from a JSON file.

!!! example "Use of the `GenerateCoefficient.py` with a JSON file named `ExampleCoefficient.json`"
    ```shell
    python3 GenerateCoefficient.py -f ExampleCoefficient.json
    ```

!!! remark "On the first and second-order derivatives"
    The Sympy interface automatically generates the C++ code not only for the function but also its first and second-order derivatives.

#### Defining a simple coefficient {#simplecoef}
This file is composed of a list of JSON objects defined by four pairs (key, value). All values are of type string.
The available keys are:

- "expression" : analytical expression of the function (required),
- "variables" : variables used in the _expression_ (required),
- "auxiliary_variables" : variables used in the _expression_ marked as auxiliary variables (optional),
- "class_name" : name of the `FunctionCoefficient`-type class, ready for use in a `Coefficient` (required),
- "outputfile" : basename of the C++ file where the _class_name_ is generated (required).

!!! example "Example of JSON file used to generate `FunctionCoefficient`-type object"

    ```json
    [
        {
        "expression":"2*x*x+30*x*y+0.1*z*x*y",
        "variables":"x y z",
        "class_name":"FunctionB",
        "outputfile":"OtherFunction"
        }
    ]
    ```

    In this example, a mathematical function of three variables is defined. The `FunctionCoefficient`-type object will named `FunctionB` and generated by the Sympy interface in the `OtherFunction.hpp` file. 

Once the `FunctionCoefficient`-type classes are generated, they can be used to define a `Coefficient`. 

!!! example "Example of `Coefficient` definition using a `FunctionCoefficient`-type object generated by the `Sympy` interface"

    ```c++
    Coefficient coeffB(Glossary::Temperature, Scheme::Implicit, FunctionB());
    ```

    This example shows the definition of a coefficient that correspond to a temperature. This coefficient is associated with the `FunctionB` object generated by the python script `script/GenerateCoefficient.py`.

!!! note "Use of a prefactor parameter in `FunctionCoefficient`"
    All `FunctionCoefficient` generated by `Sympy` interface can take one argument.

    ```c++
    Coefficient coeffB(Glossary::Temperature, Scheme::Implicit, FunctionB(a));
    ```
    
    This prefactor, here denoted by $`a`$ in `FunctionB` of the example, is a constant that multiplies the entire mathematical expression, including all of its derivatives. It is particularly useful for sensitivity analysis and for defining multiple coefficients that share the same mathematical expression but differ only by a multiplicative constant (see the use of [common coefficients](#common_coefficient)).

#### Defining a summation {#summation}
The script `GenerateCoefficient.py` is able to handle summations.

A summation can be defined directly in the JSON file.

!!! example "Example of coefficient defined as a function of summations"

    ```json
    [
    {
        "expression": "Sum( -(x[i]*x[i])/2.0 + (x[i]*x[i]*x[i]*x[i])/4.0 , (i, 1, 30) )",
        "variables": "x(1..30)",
        "class_name": "Gw",
        "outputfile": "GrainsCoefficients"
    }
    ]
    ```

    In this example, the following mathematical function is defined:

    ```math
    \begin{align*}
    \displaystyle\sum_{i=1}^{30} \left( \frac{1}{4} x_i^4 - \frac{1}{2} x_i^2 \right)
    \end{align*}
    ```

In the expression field, a summation is written using the following syntax:

`Sum( function_expression , (index, lower_bound, upper_bound) )`

where:

  - `function_expression` is the expression to be summed,
  - `index` is the summation index,
  - `lower_bound` and `upper_bound` define the summation range.

Inside the function expression, indexed variables must be written as:

  `variable_name[index]`


All variables used in the expression must be declared consistently in the variables field.

Variables are declared using the syntax:

    `variable_name(lower_bound .. upper_bound)`

For example, `x(1..30)` declares the variables ($`x_1`$, $`x_2`$,..., $`x_{30}`$ ), which can then be referenced in summation expressions using `x[i]`.

!!! warning "On the use of summation"

    - The summation bounds must be consistent with the variable declaration.
    - Indexed variables used in the expression must appear in the variables field.

Multiple summations can be defined by extending the expression field accordingly.

!!! example "Example of coefficient defined as a function of multiple summations"

    ```json
    [
        {
        "expression":"Sum( -(x[i]*x[i])/2.0  + (x[i]*x[i]*x[i]*x[i])/4.0 , (i, 1, 30)) +  Sum( (x[i]*x[i])*(x[j]*x[j]),(i, 1, 30),(j, 1, 30)) - Sum( (x[i]*x[i]),(i, 1, 30))",
        "variables":"x(1..30)",
        "class_name":"Gw",
        "outputfile":"GrainsCoefficients"
        }
    ]
    ```

    In this example, the following mathematical function is defined:

    ```math

    \begin{align*}
    \sum_{i=1}^{30} \left( \frac{1}{4} x_i^4 - \frac{3}{2} x_i^2 \right)+\sum_{i=1}^{30} \sum_{j=1,i\neq i}^{30} x_i^2 x_j^2
    \end{align*}
    
    ```

#### Defining a scalar product {#scalarproduct}

The script `GenerateCoefficient.py` is able to handle scalar product in order to define gradient energy terms.

To enable this feature, the JSON file must include the key "gradient", which is a boolean indicating whether the expression depends on a scalar product.

- false (default): the expression is not a function of a scalar product
- true: the expression is a function of a scalar product

In `SLOTH`integrators, each variable is viewed as a gradient.

!!! example "Example of coefficient defined with a scalar product"

    ```json
    [
        {
        "expression":"dot(x,x)",
        "variables":"x",
        "class_name":"GradEnergy",
        "outputfile":"GradientCoefficients",
        "gradient":true
        }
    ]
    ```

    In this example, the following mathematical function is defined:

    ```math

    \begin{align*}
    \nabla x\cdot\nabla x
    \end{align*}
    
    ```


### __ExprTk interface__ {#coef_exprtk}

Unlike the `Sympy` interface, the `ExprTk` interface does not provides the C++ code for the analytical expression or its derivatives. 

To use this interface, the user can define a `Coefficient` by passing the literal expression of the function (`std::string` type), the unknowns (`std::string` type), and optionally the derivatives (`std::vector<std::string>` type).

!!! warning "Storage of the first and second-order derivatives" 
    Derivatives are stored in `std::vector<std::string>`, considering a row-major index for the Hessian matrix ($`H(i,j)=H(i*n+j)`$ where $`n`$ is the number of unknowns).


!!! example "Definition of a `Coefficient` using the `ExprTk` interface"
    
    The following example defines the temperature coefficient as a constant. In this case, the derivatives are zero.

    ```c++
    Coefficient coeffA(Glossary::Temperature, "2"); 
    ```
    
    The following example defines the temperature coefficient as a multi-variables function. In this case, the derivatives are zero since they are not provided.

    ```c++
    Coefficient coeffA(Glossary::Temperature, Scheme::Implicit,"2*x+30*y+0.1*z", "x", "y", "z"); 
    ```
    
    The following example defines the temperature coefficient as a multi-variables function with its first-order derivatives. In this case, the second-order derivatives are zero since they are not provided.

    ```c++
      std::string function = "2*x*x+30*x*y+0.1*z*x*y";
      std::string gx = "4*x+30*y+0.1*z*y";
      std::string gy = "30*x+0.1*z*x";
      std::string gz = "0.1*x*y";
      std::vector<std::string> grad_functions{gx, gy, gz};

      Coefficient coeffA(Glossary::Temperature, Scheme::Implicit, grad_functions, function, "x", "y","z");
    ```
    
    The following example defines the temperature coefficient as a multi-variables function with its first and second-order derivatives.

    ```c++
      std::string function = "2*x*x+30*x*y+0.1*z*x*y";
      std::string gx = "4*x+30*y+0.1*z*y";
      std::string gy = "30*x+0.1*z*x";
      std::string gz = "0.1*x*y";
      std::vector<std::string> grad_functions{gx, gy, gz};
      std::string gxx = "4.0";
      std::string gxy = "30+0.1*z";
      std::string gxz = "0.1*y";
      std::string gyx = "30+0.1*z";
      std::string gyy = "0.0";
      std::string gyz = "0.1*x";
      std::string gzx = "0.1*y";
      std::string gzy = "0.1*x";
      std::string gzz = "0.0";
      std::vector<std::string> hess_functions{gxx, gxy, gxz, gyx, gyy, gyz, gzx, gyz, gzz};

      Coefficient coeffA(Glossary::Temperature, Scheme::Implicit, hess_functions, grad_functions, function, "x", "y","z");
    ```


## __Coefficients__ {#coefficients}

The C++ class `Coefficients` allows to define a collection of [`Coefficient` objects](#coefficient). 

<!-- Each `SLOTH` problem (see [Problems](../MultiPhysicsCouplingScheme/Problems/index.md) for more details) requires a `Coefficients` object as input argument. -->


!!! example "Example of `Coefficients` definition"

    ```c++
    Coefficient coeffA(Glossary::Temperature, Scheme::Implicit, "2*x+30*y+0.1*z", "x", "y", "z");
    Coefficient coeffB(Glossary::Temperature, Scheme::Implicit, FunctionB());
    
    Coefficients coeffAB = Coefficients(coeffA, coeffB);
    ```

    This example shows the definition of two coefficients gathered within a `Coefficients` object.
    The first coefficient is defined from the `ExprTk` interface and the second coefficient from the `Sympy` interface.

## __Use of coefficients in `SLOTH` problems__ {#pde_coefficient}
`SLOTH` coefficients are used in `SLOTH` [integrators when solving PDEs](../MultiPhysicsCouplingScheme/Problems/PDEs/index.md). 

Because a fully generic interface is difficult to define, the development team has adopted the following implicit conventions:

- The ordering of unknowns used when defining coefficients must match exactly the ordering of unknowns in the `Variables` object associated with the `SLOTH` problem.
- The ordering of auxiliary unknowns used when defining coefficients must match exactly the ordering of auxiliary variables specified in the `SLOTH` problem.

Failure to respect these orderings may result in incorrect coefficient evaluation or undefined behavior in existing `SLOTH` [integrators](../MultiPhysicsCouplingScheme/Problems/PDEs/index.md).

## __Common list of coefficients__ {#common_coefficient}
A common list of `SLOTH` coefficients is directly accessible in input datafile. In the following mathematical expressions, the parameter $`a`$ corresponds the [prefactor](#simplecoef) which is equal to one by default.

- `W` : double-well potential

```math

\begin{align}
W(\varphi)=a\varphi^2 (1-\varphi)^2
\end{align}

```

- `Fw` : double-well potential

```math

\begin{align}
Fw(\varphi)=a \left[0.25  ( \varphi^2 - 1.0)  ( \varphi^2 - 1.0)\right]
\end{align}

```

- `Log` : logarithm energy

```math

\begin{align}
\text{Log}(\varphi)=a \left[\varphi log(\varphi) + (1-\varphi)log(1-\varphi)\right]
\end{align}

```
where $`\varphi`$ is truncated as $`min(max(\epsilon,\varphi),1-\epsilon)`$ in order to avoid numerical difficulties in $`0`$ and $`1`$.

- `GradientEnergy` : gradient energy contribution

```math

\begin{align}
\text{GradientEnergy}(\varphi)=a \left[\dfrac{1}{2}|{\nabla \varphi}|^2\right]
\end{align}

```
where $`\varphi`$ is truncated as $`min(max(\epsilon,\varphi),1-\epsilon)`$ in order to avoid numerical difficulties in $`0`$ and $`1`$. In practice, $`\epsilon=10^{-10}`$.


