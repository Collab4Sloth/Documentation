{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SLOTH","text":"The multiphase-field multicomponent framework of the PLEIADES platform     based on MFEM  <ul> <li> <p>Features</p> <ul> <li>Phase-field modelling</li> <li>Finite Element</li> <li>Unsteady, nonlinear, coupled problems</li> <li>Massively parallel MPI implementation </li> <li>Calphad-informed phase-field</li> </ul> </li> <li> <p>News</p> <ul> <li>NuFuel workshop [9/25]</li> <li>NuMat Conference [10/24]</li> </ul> </li> <li> <p>Latest Release</p> <p> V1.0.0</p> </li> <li> <p>Contact</p> <p>Use the Github issue tracker to report bugs or comments. </p> <p>See the About page for contact and license information.</p> </li> </ul>"},{"location":"About/index.html","title":"About the SLOTH project","text":""},{"location":"About/index.html#project-summary","title":"Project summary","text":"<p>Phase-field methods represent a versatile and effective approach to modelling the spatiotemporal evolution of complex physical systems that exhibit significant heterogeneities, such as phase transitions, coalescence, and cracking. These methods have found extensive application in the field of materials science, including in the modelling of the behaviour of nuclear fuels. </p> <p>The phase-field approach has also been employed in recent studies conducted with the multiphysics computational tools of the PLEIADES platform<sup>1</sup>. Broadly speaking, the <code>PLEIADES</code>/Fuel Performance Codes<sup>2</sup> aim at providing a state-of-the-art multiphysics multiscale description of the fuel under irradiated conditions. The inclusion of an advanced multiphysics and multiscale modelling such as phase-field, is a logical step forward. Consequently, the CEA is developing SLOTH, a multiphase-field multicomponent framework, dedicated to the study of fuel behaviour at different scales of description, from nominal operating conditions to severe accident conditions. </p> <p><code>PLEIADES/SLOTH</code> is developed at CEA under LPGL license (Version 3). It is based on the the <code>MFEM</code> Finite Element library<sup>3</sup>, which already includes the main features to have a robust, flexible and massively parallel implementation of the solution algorithms.</p> <p>[Incipient melting in a pellet fragment under an ad-hoc temperature dependent enthalpy of melting](https://github.com/Collab4Sloth/Gallery)</p> <p>[Polycristalline microstructure with 30 grains](https://github.com/Collab4Sloth/Gallery)</p> <p>[Spinodal decomposition](https://github.com/Collab4Sloth/Gallery)</p>"},{"location":"About/index.html#contributors","title":"Contributors","text":"<ul> <li> <p>Development Team</p> <ul> <li>Cl\u00e9ment Intro\u00efni</li> <li>Rapha\u00ebl Prat</li> </ul> </li> <li> <p>Living Deep Neural Network</p> <ul> <li>Romain Le Tellier</li> <li>Tommaso Barani</li> <li>Mathis Plapp</li> <li>Isabelle Rami\u00e8re</li> <li>Luca Messina</li> <li>J\u00e9r\u00f4me Sercombe</li> </ul> </li> <li> <p>Students Team</p> <ul> <li>Alessandro Scapini (PhD 2024-2027)</li> <li>Cl\u00e9ment Plumecocq (PhD 2023-2026)</li> <li>Victor Navarre (Master 2025)</li> <li>Jules Czuckermand (Master 2025) </li> <li>Mouad Bakhkakh (Master 2024)</li> <li>Etienne Delobre (Master 2023)</li> </ul> </li> </ul> <ol> <li> <p>St\u00e9phane Bernaud, Isabelle Rami\u00e8re, Guillaume Latu, and Bruno Michel. Pleiades: a numerical framework dedicated to the multiphysics and multiscale nuclear fuel behavior simulation. Annals of Nuclear Energy, 205:110577, 2024.\u00a0\u21a9</p> </li> <li> <p>C Intro\u00efni, I Rami\u00e8re, J Sercombe, B Michel, T Helfer, and J Fauque. Alcyone: the fuel performance code of the pleiades platform dedicated to pwr fuel rods behavior. Annals of Nuclear Energy, 207:110711, 2024.\u00a0\u21a9</p> </li> <li> <p>Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell, Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron Fisher, Tzanio Kolev, and others. Mfem: a modular finite element methods library. Computers &amp; Mathematics with Applications, 81:42\u201374, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Applications/index.html","title":"Applications","text":"<p>This page will provide an overview of applications performed with <code>SLOTH</code>.</p>"},{"location":"Documentation/Code/index.html","title":"Index","text":""},{"location":"Documentation/Code/index.html#_1","title":"Index","text":""},{"location":"Documentation/Physical/index.html","title":"Modelling Description","text":"<p>Phase-field methods are a versatile and effective approach for modeling the spatiotemporal evolution of complex physical systems involving topology changes and phase transformation. These methods have found widespread applications in materials science, including the modeling of nuclear fuel behavior.</p> <p> Contrary to sharp interfaces models in which the interfaces are viewed as discontinuous surfaces with excess physical properties, phase-field modeling considers the interfaces as thin regions of finite thickness across which variables vary continuously and smoothly. With such a diffuse description of the interfaces, phase-field modeling enables an implicit tracking of the interfaces thanks to intensive phase-field variables that are constant in each bulk phase and vary smoothly across the interfaces (see, for example, the variable \u03c6\\varphi\u03c6 in the figure).</p> <p>Phase-field modeling is an interesting approach, but it is subject to constraints related to scale separation because, in practice, the physical interface thickness is much smaller than the characteristic length scale of the materials.  Consequently, in order to make quantitative numerical simulations, an artificial thickening of the interface is introduced,  but rigorously justified with a careful parameterization of the phase-field models. </p> <p>Another advantage of phase-field models is their natural coupling with thermodynamics. The thermodynamic description of a physical system relies on classical state variables (e.g. temperature, pressure, volume, strain, ...), phase-field variables, and an energy functional, which can generally be written in the following form:</p> <p>F=\u222b\u03a9(F0+Fint)d\u03a9 \\begin{align*} \t \\mathcal{F} &amp;= \\displaystyle\\int_{\\Omega} \\left(F_{0} + F_{int}\\right)d\\Omega \\end{align*} F\u200b=\u222b\u03a9\u200b(F0\u200b+Fint\u200b)d\u03a9\u200b</p> <p>where F0F_{0}F0\u200b is the density of energy per unit volume (e.g. elastic, chemical, magnetic, ...) and FintF_{int}Fint\u200b a density of energy associated with the interfaces and allowing a diffuse description of the interfaces.</p> <p> For example, in the case of a two-phase system, under isothermal and isobaric conditions, the density of energy can be expressed in the following form: <p>F(\u03d5)=\u222b\u03a9Fw(\u03d5)+12\u03bb\u2225\u2207\u03d5\u22252d\u03a9  \\begin{align*} \\mathcal{F}(\\phi) &amp;=&amp; \\displaystyle \\int_{\\Omega} F_w(\\phi) + \\dfrac{1}{2} \\lambda \\lVert \\boldsymbol{\\nabla} \\phi \\lVert^2 d\\Omega \\end{align*}  F(\u03d5)\u200b=\u200b\u222b\u03a9\u200bFw\u200b(\u03d5)+21\u200b\u03bb\u2225\u2207\u03d5\u22252d\u03a9\u200b</p></p> <p>where \u03bb\\lambda\u03bb is an energy gradient coefficient and Fw(\u03d5)=\u03c9\u03d52(1\u2212\u03d5)2F_w(\\phi)=\\omega \\phi^2(1-\\phi)^2Fw\u200b(\u03d5)=\u03c9\u03d52(1\u2212\u03d5)2 a double-well potential with \u03c9\\omega\u03c9 the depth of the double-well. In practice, closure relations allows to formulate \u03bb\\lambda\u03bb and \u03c9\\omega\u03c9 as function of the thickness of interface and the surface tension.</p> <p>The governing equations associated with the evolution of a physical system can be derived from the minimization of the energy functional F\\mathcal{F}F. In the context of the phase-field modelling, two historical phase-field models can be derived: the Cahn-Hilliard model<sup>1</sup> and the Allen-Cahn model<sup>2</sup>.</p> <p>Cahn-Hilliard- &amp; Allen-Cahn-type models</p> Cahn-HilliardAllen-Cahn <p>\u2202\u03d5i\u2202t=\u2207\u22c5[\u2211kMi,k\u2207\u03b4F\u03b4\u03d5k]\u00a0in\u00a0\u03a9\u2211i\u03d5i=1  \\begin{align*} \\frac{\\partial \\phi_i}{\\partial t}&amp;= \\nabla \\cdot \\left[\\sum_{k} M_{i,k} \\nabla \\frac{\\delta \\mathcal{F}}{\\delta \\phi_k}\\right] \\text{ in }\\Omega  \\\\[6pt]     \\sum_{i}\\phi_i &amp;=1 \\end{align*}  \u2202t\u2202\u03d5i\u200b\u200bi\u2211\u200b\u03d5i\u200b\u200b=\u2207\u22c5[k\u2211\u200bMi,k\u200b\u2207\u03b4\u03d5k\u200b\u03b4F\u200b]\u00a0in\u00a0\u03a9=1\u200b</p> <p>where \u03d5i\\phi_i\u03d5i\u200b are phase indicators and Mi,kM_{i,k}Mi,k\u200b mobility coefficients.</p> <p>\u2202\u03d5i\u2202t=\u2212[\u2211kLi,k\u2207\u03b4F\u03b4\u03d5k]\u00a0in\u00a0\u03a9\u2211i\u03d5i=1  \\begin{align*}  \\frac{\\partial \\phi_i}{\\partial t}&amp;= -\\left[\\sum_{k} L_{i,k} \\nabla \\frac{\\delta \\mathcal{F}}{\\delta \\phi_k}\\right] \\text{ in }\\Omega  \\\\[6pt]     \\sum_{i}\\phi_i &amp;=1 \\end{align*}  \u2202t\u2202\u03d5i\u200b\u200bi\u2211\u200b\u03d5i\u200b\u200b=\u2212[k\u2211\u200bLi,k\u200b\u2207\u03b4\u03d5k\u200b\u03b4F\u200b]\u00a0in\u00a0\u03a9=1\u200b</p> <p>where \u03d5i\\phi_i\u03d5i\u200b are phase indicators and Li,kL_{i,k}Li,k\u200b mobility coefficients.</p> <p>Based on these two historical models, a wide range of phase-field models has been developed. <code>SLOTH</code> provides the features needed to solve both Cahn\u2013Hilliard-type and Allen\u2013Cahn-type models. In addition, since it is dedicated to studying fuel behavior across different scales, from nominal operating conditions to severe accident scenarios, <code>SLOTH</code> also offers a suite of features for performing multiphysics simulations, including phase-field, thermal diffusion, multicomponent diffusion<sup>3</sup>, and CALPHAD thermodynamic calculations.</p> <p>Multicomponent diffusion</p> <p>Inter-diffusion equations in the following form can be solved by <code>SLOTH</code>. </p> <p>\u2202xi\u2202t=\u2207\u22c5\u2211i=1n\u22121[Mi,n\u2207(\u03bci\u2212\u03bcn)]\u00a0in\u00a0\u03a9\u2211i=1nxi=1  \\begin{align*} \\frac{\\partial x_i}{\\partial t}&amp;= \\nabla \\cdot \\sum_{i=1}^{n-1}\\left[M_{i,n} \\nabla (\\mu_i-\\mu_n)\\right]  \\text{ in }\\Omega  \\\\[6pt]     \\sum_{i=1}^{n} x_i&amp;=1  \\end{align*}  \u2202t\u2202xi\u200b\u200bi=1\u2211n\u200bxi\u200b\u200b=\u2207\u22c5i=1\u2211n\u22121\u200b[Mi,n\u200b\u2207(\u03bci\u200b\u2212\u03bcn\u200b)]\u00a0in\u00a0\u03a9=1\u200b</p> <p>where xix_ixi\u200b denotes the molar fraction of the component iii, \u03bci\\mu_i\u03bci\u200b the chemical potential of the component iii and Mi,nM_{i,n}Mi,n\u200b inter-diffusion mobility coefficients.</p> <p>Fickian diffusion is also available in <code>SLOTH</code>. </p> <p>Heat transfer</p> <p>Heat transfer equation in the following form can be solved in <code>SLOTH</code></p> <p>\u03c1Cp\u2202T\u2202t=\u2207\u22c5k\u2207T+S+L\u00a0in\u00a0\u03a9  \\begin{align*} \\rho C_p\\frac{\\partial T}{\\partial t}&amp;= \\nabla \\cdot k \\nabla T + \\mathcal{S} +  \\mathcal{L}  \\text{ in }\\Omega  \\end{align*}  \u03c1Cp\u200b\u2202t\u2202T\u200b\u200b=\u2207\u22c5k\u2207T+S+L\u00a0in\u00a0\u03a9\u200b</p> <p>where \u03c1\\rho\u03c1 is the molar density, CpC_pCp\u200b the molar heat capacity, kkk the thermal conductivity, S\\mathcal{S}S a heat generation rate, L\\mathcal{L}L a latent heat due to phase changes, and TTT the temparature.</p> <p>CALPHAD-informed phase-field simulations</p> <p>The CEA has developed under a proprietary license a software interface to the OpenCalphad thermodynamic solver<sup>4</sup> <sup>5</sup>. The source code is not available to unauthorized users.  However, the <code>SLOTH</code> development team remains available to provide first-level support to any user wishing to interface their own Gibbs Energy Minimizer (provided it is compatible with the <code>SLOTH</code> license).</p> <ol> <li> <p>John W Cahn and John E Hilliard. Free energy of a nonuniform system. i. interfacial free energy. The Journal of chemical physics, 28(2):258\u2013267, 1958.\u00a0\u21a9</p> </li> <li> <p>Samuel M Allen and John W Cahn. A microscopic theory for antiphase boundary motion and its application to antiphase domain coarsening. Acta metallurgica, 27(6):1085\u20131095, 1979.\u00a0\u21a9</p> </li> <li> <p>Cl\u00e9ment Intro\u00efni, J\u00e9r\u00f4me Sercombe, Christine Gu\u00e9neau, and Bo Sundman. Modeling oxygen transport in cr doped uo2 fuel with the taf-id during power transients. Journal of Nuclear Materials, 603:155352, 2025.\u00a0\u21a9</p> </li> <li> <p>Bo Sundman, Xiao-Gang Lu, and Hiroshi Ohtani. The implementation of an algorithm to calculate thermodynamic equilibria for multi-component systems with non-ideal phases in a free software. Computational Materials Science, 101:127\u2013137, 2015.\u00a0\u21a9</p> </li> <li> <p>Bo Sundman, Ursula R Kattner, Mauro Palumbo, and Suzana G Fries. Opencalphad-a free thermodynamic software. Integrating Materials and Manufacturing Innovation, 4(1):1, 2015.\u00a0\u21a9</p> </li> </ol>"},{"location":"Documentation/User/index.html","title":"User manual","text":"<p>Figure 1 shows a schematic overview of the <code>SLOTH</code> features.</p> Figure 1 : schematic overview of the `SLOTH` features  <p><code>SLOTH</code> is developed on top of <code>MFEM</code> <sup>1</sup>. It is implemented in C++ and the software build process is managed with CMake. </p> <p>This page focuses on the kernel of <code>SLOTH</code>, providing all the essential information users need to construct or modify a <code>SLOTH</code> data file. This includes:</p> <ul> <li>Variables and Parameters</li> <li>Spatial discretisation, including the <code>SLOTH</code> objects Meshing and BoundaryConditions</li> <li>Multiphysics coupling scheme, including the <code>SLOTH</code>objects TimeDiscretization, Coupling, Problems and Convergence</li> <li>Post-Processing</li> <li>Profiling</li> </ul> <p>On the use of tutorials</p> <p>Development team recommend visiting the tutorials page to discover tips and tricks for specific <code>SLOTH</code> features</p> <p><code>MFEM</code> documentation</p> <p>For further details regarding dependencies, advanced numerical methods, and massively parallel features, users are referred to the MFEM website.</p> <p>Installation guide</p> <p>In addition, users are referred to the <code>Getting started</code> page for more details about the installation and compilation of <code>SLOTH</code>. </p> <ol> <li> <p>Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell, Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron Fisher, Tzanio Kolev, and others. Mfem: a modular finite element methods library. Computers &amp; Mathematics with Applications, 81:42\u201374, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Documentation/User/AnalyticalVariables/index.html","title":"AnalyticalFunctions (Coming soon)","text":"<p>This page provides a comprehensive overview of the analytical functions available in <code>SLOTH</code>, along with detailed instructions on how to define each function.</p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/index.html","title":"MultiPhysics Coupling Scheme","text":"<p>For <code>SLOTH</code>, the time loop of all multiphysics simulations is managed by the C++ object <code>TimeDiscretization</code>.</p> <p>Figure 1 schematically represents a time-step of a <code>SLOTH</code> multiphysics simulations.</p> Figure 1 : Schematic description of one time-step for `SLOTH` simulations  <p>It consists of two nested loops.</p> <p>The first loop corresponds to solving a set of Couplings using a partitioned algorithm.</p> <p>For each coupling, there is an inner loop over a set of Problems, each solved either with a partitioned or a monolithic algorithm. </p> <p>Depending on the simulation, users can also activate Convergence criteria.</p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Convergence/index.html","title":"Convergence","text":"<p>Definition of convergence criteria for <code>SLOTH</code> is made with a C++ object of type <code>Convergence</code> which is a collection of C++ objects of type <code>PhysicalConvergence</code>.</p> <p>Currently, the <code>Convergence</code> object enables to find the steady solution from a transient calculation. </p> <p>For this purpose, it must be added to the list of parameters when defining the problem.</p> <p>The number and order of <code>PhysicalConvergence</code> objects defining a <code>Convergence</code> object must match the number and order of the <code>Variable</code> objects collected in the <code>Variables</code>object of the problem.</p> <p>The <code>PhysicalConvergence</code> objects are defined by:</p> <ul> <li>a type of criterion: the maximum of the absolute (<code>ConvergenceType::ABSOLUTE_MAX</code>) and/or relative (<code>ConvergenceType::RELATIVE_MAX</code>) error between two successive time-steps</li> <li>a threshold (type <code>double</code>)</li> </ul> <p>Definition of a problem with two unknowns and a <code>Convergence</code> object</p> <p>This example assume a simulation based on a problem defined with a fictitious <code>Operator</code> (see <code>my_operator</code>), <code>Variables</code> (see <code>my_variables</code>) and <code>PostProcessing</code> (see <code>my_post_processing</code>). </p> <p>For this problem, there are two variables <code>phi</code> and <code>mu</code>.</p> <p>Two <code>PhysicalConvergence</code> objects are then defined to find the steady solution from a transient calculation. When both convergence criteria are satisfied, the calculation stops normally.</p> <pre><code>auto phi_cvg = PhysicalConvergence(ConvergenceType::ABSOLUTE_MAX, 1.e-12);\nauto mu_cvg = PhysicalConvergence(ConvergenceType::ABSOLUTE_MAX, 1.e-7);\n\nauto conv_criteria = Convergence(phi_cvg, mu_cvg);\n\nProblem&lt;OPE, VARS, PST&gt; my_problem(my_operator, my_variables, my_post_processing, conv_criteria);\n</code></pre> <p>On the use of <code>Convergence</code> objects</p> <p>From now, the <code>Convergence</code> objecs are only used to find steady solution from a transient calculation. </p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Couplings/index.html","title":"Couplings","text":"<p>This page described how to define and manage couplings in <code>SLOTH</code>.</p> <p>Couplings for <code>SLOTH</code> are made with a C++ object of type <code>Coupling</code>.  They must be defined by:</p> <ul> <li>a coupling name (C++ type std::string),</li> <li>a set of problems defined by C++ objects of type <code>Problem</code> (see the dedicated page of the user manual)</li> </ul> <p>Defining and using couplings</p> <p><pre><code>auto coupling_example_1 = Coupling(\"MyCoupling1\", Problem1_1, Problem1_2, Problem1_3);\nauto coupling_example_2 = Coupling(\"MyCoupling2\", Problem2_1, Problem2_2, Problem2_3);\n</code></pre> This example shows how to define two <code>Coupling</code> objects, here named \"MyCoupling1\" and \"MyCoupling2\". Each coupling is instantiated with three fictitious problems.</p> <p>These couplings may be then used to instantiated a TimeDiscretization object to build a multiphysics coupling scheme. </p> <pre><code>auto time = TimeDiscretization(time_parameters, coupling_example_1, coupling_example_2);\n</code></pre>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/index.html","title":"Problems","text":"<p><code>SLOTH</code> provides three main types of <code>Problems</code>: </p> <ul> <li>Partial Differential Equations (PDEs) </li> <li>0D problems </li> <li>Other types, referred to as \"the remainder\" </li> </ul> Figure 1 : Schematic description of one time-step for `SLOTH` simulations with the three main types of `Problems`.  <p>Each of these problems can be combined to be solved within a <code>Coupling</code> using a partitioned algorithm.</p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/0D/index.html","title":"0D problems","text":"<p>Currently, only CALPHAD problems are available as 0D models. </p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/0D/index.html#calphad","title":"CALPHAD problems","text":"<p>Definition of CALPHAD problems for <code>SLOTH</code> is made with a C++ object of type <code>Calphad_Problem</code>. </p> <p><code>Calphad_Problem</code> is a template class instantiated with three template parameters: first, a CALPHAD object, second, the <code>Variables</code> object, and third, the <code>Postprocessing</code> object.</p> <p>Alias declaration for <code>Calphad_Problem</code> class template</p> <pre><code>using CalphadProblem = Calphad_Problem&lt;CALPHAD, VARS, PST&gt;;\n</code></pre> <p><code>Calphad_Problem</code> objects are defined by</p> <ul> <li>a collection of parameters (<code>SLOTH</code> type `Parameters'),</li> <li>a collection of primary variables (<code>SLOTH</code> type `Variables'),</li> <li>a post-processing (<code>SLOTH</code> type <code>PostProcessing</code>),</li> <li>auxiliary variables  (<code>SLOTH</code> type `Variables').</li> </ul> <p>The parameters will be defined later on this page. Here, the focus is made on the variables. It is important to keep in mind that the inputs of the <code>Calphad_Problem</code> are the auxialiary variables whereas the outputs correspond the primary variables (see the dedicated page of the manual for more details about <code>Variable</code> objects).</p> <p>The inputs are the initial conditions expressed in terms of temperature, pressure and composition. When performing multiphysics simulations involving heat transfer, mass diffusion and CALPHAD calculations, it is often preferable to use separate auxiliary variables rather than a single and unified collection of variables within one <code>Variables</code> object.</p> <p>Definition of a fictitious  <code>Calphad_Problem</code></p> <p><pre><code>auto  my_calphad_problem = CalphadProblem(params, outputs, calphad_pst, T, P, composition);\n</code></pre> In this example, a fictitious <code>Calphad_Problem</code>is defined with <code>Parameters</code> (see <code>params</code>), outputs (primary <code>Variables</code>) and inputs (auxiliary <code>Variables</code>, here T, P, composition)</p> <p>All <code>Calphad_problems</code> share a set of optional output variables. For each variable, additional information must be provided in accordance with the semantics summarized in the table 1.</p> Property Symbol Additional information order chemical potentials <code>mu</code> (element, symbol) diffusion chemical potentials <code>dmu</code> (element, symbol) mole fraction of phase <code>xph</code> (phase, symbol) element mole fraction by phase <code>x</code> (phase, element, symbol) site fraction by sublattice by phase <code>y</code> (species, sublattice number, phase, symbol) (molar) Gibbs energy and (molar) enthalpy of phase <code>g</code>, <code>gm</code>, <code>h</code>, <code>hm</code> (phase, symbol) driving forces <code>dgm</code> (phase, symbol) heat capacity <code>cp</code> (symbol) mobilities <code>mob</code> (phase, element, symbol) nucleus <code>nucleus</code> (phase,symbol) error equilibrium <code>error</code> (symbol) Table 1 - Semantics for defining the additional information of CALPHAD <code>Variables</code> <p>On the use of additional information for CALPHAD output variables</p> <ul> <li>Additional information must always be provided as specified in the table 1</li> <li>The last additional information is always the symbol associated with the variable. </li> </ul> <p>Defining fictitious CALPHAD variables</p> <p>The following example consider a binary system U-O in a LIQUID-SOLID mixture.  Five <code>Variable</code> objects are defined and collected within a <code>Variables</code> object. </p> <pre><code>// Oxygen chemical potential\nauto muo = VAR(&amp;spatial, bcs, \"muO\", level_of_storage, 0.);\nmuo.set_additional_information(\"O\", \"mu\");\n\n// Oxygen mobility in the phase SOLID\nauto mobO = VAR(&amp;spatial, bcs, \"Mo\", level_of_storage, 0.);\nmobO.set_additional_information(\"SOLID\", \"O\", \"mob\");\n\n// Molar fraction of the phase LIQUID\nauto xph_l = VAR(&amp;spatial, bcs, \"xph_l\", level_of_storage, 0.);\nxph_l.set_additional_information(\"LIQUID\", \"xph\");\n\n// Site fraction of the cation U+3\nauto yu = VAR(&amp;spatial, bcs, \"yu+3\", level_of_storage, 0.);\nyu.set_additional_information(\"U+3\", \"0\", \"SOLID\", \"y\");\n\n// Gibbs energy\nauto gl = VAR(&amp;spatial, bcs, \"g_l\", level_of_storage, 0.);\ngl.set_additional_information(\"LIQUID\", \"g\");\n\nauto calphad_outputs = VARS(muo, mobO, xph_l, yu, gl);\n</code></pre> <p>At this stage, the <code>CALPHAD</code> object in <code>Calphad_Problem</code> remains to be defined. It corresponds to a <code>SLOTH</code> C++ object that inherits from the  template class <code>CalphadBase&lt;mfem::Vector&gt;</code>. It specializes the model to calculate thermodynamic properties. </p> <p>Depending on the simulation, three kind of <code>CALPHAD</code> models are currently available:</p> <ul> <li>a Gibbs Energy Minimizer</li> <li>an analytical thermodynamic model</li> <li>metamodels</li> </ul> <p>Users will find on this page all information to define and use these <code>CALPHAD</code> models. </p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/0D/index.html#gem","title":"Gibbs Energy Minimizer (GEM)","text":"<p>A generic software interface is available for users who want to couple <code>SLOTH</code> with their own GEM.</p> <p>The <code>SLOTH</code> development team remains available to provide first-level support to any user wishing to interface their own GEM (provided it is compatible with the <code>SLOTH</code> license).</p> <p>Coupling between SLOTH and OpenCalphad</p> <p>The CEA has developed under a proprietary license a software interface to the OpenCalphad thermodynamic solver<sup>1</sup><sup>2</sup>. The source code is not available to unauthorized users. </p>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/0D/index.html#analytical","title":"Analytical thermodynamic model","text":"<p>In many multiphysics simulations involving thermodynamic equilibrium calculations, the thermodynamic description relies on analytical formulas.</p> <p>This capability is illustrated in <code>SLOTH</code> with the object <code>AnalyticalIdealSolution&lt;mfem::Vector&gt;</code>, which computes the Gibbs free energy and the chemical potential for an ideal-solution phase.</p> <p>g(x,T)=RT(xln(x)+(1.0\u2212x)ln(1.0\u2212x)) \\begin{align} g(x,T)&amp;= R T (x ln(x) + (1.0 - x) ln(1.0 - x)) \\end{align} g(x,T)\u200b=RT(xln(x)+(1.0\u2212x)ln(1.0\u2212x))\u200b\u200b</p> <p>where RRR is the  molar gas constant, TTT the temperature and xxx the molar fraction.</p> <p>On the use of the <code>AnalyticalIdealSolution</code> object</p> <p>The <code>AnalyticalIdealSolution&lt;mfem::Vector&gt;</code> object is mainly intended for code analyses involving <code>Calphad_Problem</code> and as an example to guide users in building and using a <code>CALPHAD</code> model. </p> <p>Definition of a <code>Calphad_Problem</code> based on <code>AnalyticalIdealSolution&lt;mfem::Vector&gt;</code></p> <p>In this example, a fictitious <code>Calphad_Problem</code> based on <code>AnalyticalIdealSolution&lt;mfem::Vector&gt;</code> is defined with <code>Parameters</code> (see <code>calphad_parameters</code>), outputs (primary <code>Variables</code>) and inputs (auxiliary <code>Variables</code>, here T, P, composition)</p> <pre><code>Calphad_Problem&lt;AnalyticalIdealSolution&lt;mfem::Vector&gt;, VARS, PST&gt;  my_calphad_problem = CalphadProblem(calphad_parameters, outputs, calphad_pst, T, P, composition);\n</code></pre>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/0D/index.html#ia","title":"Metamodels","text":"<p>SLOTH can also be linked to the libtorch library to use serialized <code>PyTorch</code> models for approximating the behavior of a GEM. </p> <p><code>CalphadInformedNeuralNetwork&lt;mfem::Vector&gt;</code> is an object developed to compute mobilities, chemical potentials,  Gibbs free energy, and enthalpy for unary to n-ary systems either in a single phase or in a two phase mixture.  This list of predicted thermodynamic quantities could be extended. </p> <p>Users can either employ a dedicated neural network for each thermodynamic quantity or use a single neural network for all properties.</p> <p>On the use of several metamodels</p> <p>All metamodels must share the same input variables, provided in the same order.</p> <p>The parameters associated with <code>CalphadInformedNeuralNetwork&lt;mfem::Vector&gt;</code> are detailed in the table 3.</p> Parameter Name Type Default Value Description <code>\"ChemicalPotentialsNeuralNetwork\"</code> <code>vTupleStringString</code> Name of the serialized <code>PyTorch</code> model for chemical potentials by phase <code>\"ChemicalPotentialsNeuralNetworkIndex\"</code> <code>vTupleStringInt</code> Index of the first chemical potential in the metamodel outputs, by phase <code>\"MobilitiesNeuralNetwork\"</code> <code>vTupleStringString</code> Name of the serialized <code>PyTorch</code> model for mobilities <code>\"MobilitiesNeuralNetworkIndex\"</code> <code>vTupleStringInt</code> Index of the first mobility in the metamodel outputs, by phase <code>\"EnergiesNeuralNetwork\"</code> <code>vTupleStringString</code> Name of the serialized <code>PyTorch</code> model for Gibbs energy and enthalpy <code>\"EnergiesNeuralNetworkIndex\"</code> <code>vTupleStringInt</code>** Index of the first energy in the metamodel outputs, by phase <code>\"InputEnergiesOrder\"</code> <code>vString</code> Order of the energy potentials in the metamodel outputs (e.g. <code>{\"G\",\"H\"}</code>) <code>\"InputCompositionOrder\"</code> <code>vString</code> Order of the elements in the metamodel inputs (e.g. <code>{\"O\",\"PU\", \"U\"}</code>) <code>\"ModelBuiltWithPressure\"</code> <code>bool</code> <code>True</code> Flag to indicate if the pressure is an input of the metamodel <code>\"OwnMobilityModel\"</code> <code>bool</code> <code>True</code> Flag to indicate if a different metamodel is used for mobilities <code>\"OwnEnergyModel\"</code> <code>bool</code> <code>True</code> Flag to indicate if a different metamodel is used for energies <code>\"InputCompositionFactor\"</code> <code>double</code> <code>1.0</code> By default, initial composition is expressed in terms of molar fractions of  elements. This parameter should be used when the metamodels are built with moles. <code>\"GivenPhase\"</code> <code>std::string</code> <code>\"\"</code> When working for a single phase, its name is given by this paramter. <code>\"element_removed_from_nn_inputs\"</code> <code>std::string</code> By default, initial composition is expressed in terms of molar fraction of elements. This parameter should be used to define the element deduced from other thanks to the relation \u2211ixi=1\\sum_{i} x_i=1\u2211i\u200bxi\u200b=1 Table 3 - Parameters associated with <code>CalphadInformedNeuralNetwork</code> <p>Inputs of metamodels</p> <p>The inputs of the metamodels are assumed to be the temperature, the pressure (if used during the construction of the metamodels), and the composition.</p> <p>Definition of a <code>Calphad_Problem</code> based on <code>CalphadInformedNeuralNetwork&lt;mfem::Vector&gt;</code></p> <p>This example assume that metamodels are used to approximate chemical potentials and mobilities for the U-Pu-O ternary system in a liquid-solid mixture.</p> <p>The serialized <code>PyTorch</code>models are named <code>solid_model.pt</code> and <code>liquid_model.pt</code> for the solid and liquid, respectively.</p> <p>The same metamodel is used both for chemical potentials and mobilities in the solid phase. </p> <p>Among the outputs, first chemical potential is found at index 777 for the solid phase and 444 for the liquid phase. Regarding the mobilities in the solid phase, first output is found at index 444.</p> <pre><code>vTupleStringString CommonNeuralNetwork;\nCommonNeuralNetwork.emplace_back(std::make_tuple(\"solid_model.pt\", \"SOLID\"));\nCommonNeuralNetwork.emplace_back(std::make_tuple(\"liquid_model.pt\", \"LIQUID\"));\n\nauto neural_network_model_mu = Parameter(\"ChemicalPotentialsNeuralNetwork\", CommonNeuralNetwork);\nvTupleStringInt ChemicalPotentialNeuralNetworkIndex;\nChemicalPotentialNeuralNetworkIndex.emplace_back(std::make_tuple(\"SOLID\", 7));\nChemicalPotentialNeuralNetworkIndex.emplace_back(std::make_tuple(\"LIQUID\", 4));\nauto index_neural_network_model_mu =\n    Parameter(\"ChemicalPotentialsNeuralNetworkIndex\", ChemicalPotentialNeuralNetworkIndex);\n\nvTupleStringInt MobilitiesNeuralNetworkIndex;\nMobilitiesNeuralNetworkIndex.emplace_back(std::make_tuple(\"SOLID\", 4));\n\nvTupleStringString MobNeuralNetwork;\nMobNeuralNetwork.emplace_back(std::make_tuple(\"solid_model.pt\", \"SOLID\"));\nauto neural_network_model_mob = Parameter(\"MobilitiesNeuralNetwork\", MobNeuralNetwork);\nauto index_neural_network_model_mob =\n    Parameter(\"MobilitiesNeuralNetworkIndex\", MobilitiesNeuralNetworkIndex);\n\nstd::vector&lt;std::string&gt; composition_order{\"O\", \"PU\", \"U\"};\nauto input_composition_order = Parameter(\"InputCompositionOrder\", composition_order);\n\nauto own_mobility_model = Parameter(\"OwnMobilityModel\", false);\n\nauto element_removed_from_nn_inputs = Parameter(\"element_removed_from_nn_inputs\", \"PU\");\n</code></pre> <p>These parameters are then collected into a <code>Parameters</code> object and use to define the <code>Calphad_Problem</code></p> <pre><code>auto calphad_parameters = Parameters(neural_network_model_mu, index_neural_network_model_mu, \n                                     neural_network_model_mob, index_neural_network_model_mob,\n                                    own_mobility_model, input_composition_order, \n                                    element_removed_from_nn_inputs) \n\nCalphad_Problem&lt;CalphadInformedNeuralNetwork&lt;mfem::Vector&gt;, VARS, PST&gt;  my_calphad_problem = CalphadProblem(calphad_parameters, outputs, calphad_pst, T, P, composition);\n</code></pre> <ol> <li> <p>Bo Sundman, Xiao-Gang Lu, and Hiroshi Ohtani. The implementation of an algorithm to calculate thermodynamic equilibria for multi-component systems with non-ideal phases in a free software. Computational Materials Science, 101:127\u2013137, 2015.\u00a0\u21a9</p> </li> <li> <p>Bo Sundman, Ursula R Kattner, Mauro Palumbo, and Suzana G Fries. Opencalphad-a free thermodynamic software. Integrating Materials and Manufacturing Innovation, 4(1):1, 2015.\u00a0\u21a9</p> </li> </ol>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/PDEs/index.html","title":"Partial Differential Equations","text":"<p>Partial Differential Equations (PDEs) are the most important kind of problem for <code>SLOTH</code>.</p> <p>As illustrated in the figure 1, PDEs for <code>SLOTH</code> can be expressed in the following form:</p> <p>F(U(x,t))=G(U(x,t))  \\begin{align} F(U(x,t))&amp;=G(U(x,t)) \\end{align}  F(U(x,t))\u200b=G(U(x,t))\u200b\u200b</p> <p>where U(x,t)U(x,t)U(x,t) is the vector of unknowns expressed as a function of the time ttt and the position xxx. In this equation, FFF and GGG are two nonlinear forms associated with the time derivative operator and the differential operators, respectively. For steady problem, F=0F=0F=0.</p> Figure 1 : Schematic description of one time-step for `SLOTH` simulations with a focus on PDEs.  <p>For <code>SLOTH</code>, all PDEs are solved using a unified nonlinear algorithm based on the Newton solver. This approach is adopted to maximize the generality of the implementation, although it may incur a minor computational overhead for linear PDEs.</p> <p>On the use of a Newton Solver</p> <p>The use of a Newton solver represents a pragmatic choice. Nevertheless, the code has been structured in such a way that alternative algorithms can be incorporated in the future.</p> <p>Definition of PDEs for <code>SLOTH</code> is made with a C++ object of type <code>Problem</code>, which is a template class instantiated with three template parameters: first, an <code>OPERATOR</code> object, second, a Variables object (see <code>VARS</code> in the example), and third, a PostProcessing object (see <code>PST</code> in the example).</p> <p>Alias declaration for <code>Problem</code> class template</p> <pre><code>using PDE = Problem&lt;OPERATOR, VARS, PST&gt;;\n</code></pre> <p>The <code>OPERATOR</code> object in <code>Problem</code> refers to an object that inherits from base classes responsible for solving the nonlinear system (1).  These classes are illustrated in the figure 2: <code>OperatorBase</code> is a base class with two child classes -- <code>TransientOperatorBase</code>, which inherits from the <code>TimeDependentOperator</code> class of <code>MFEM</code>, and <code>SteadyOperatorBase</code>, which inherits from the <code>Operator</code> class of <code>MFEM</code>. </p> Figure 2 : Three main classes managing the resolution of the non linear system.  <p>In addition to these three classes, there are two classes used to compute the residual and the Jacobian associated with the Newton-Raphson algorithm -- see <code>ReducedOperator</code> and <code>SteadyReducedOperator</code> classes in the figure 2.</p> <p>Based on these classes, specific operators have been implemented to solve:</p> <ul> <li>phase-field problems (see <code>PhaseFieldOperator</code> in the figure 3),</li> <li>heat transfer problems (see <code>HeatOperator</code> in the figure 3),</li> <li>multicomponent diffusion problems (see <code>DiffusionOperator</code> in the figure 3).</li> </ul> <p>Transient and steady versions of these specific operators are available.</p> Figure 3 : Specific `Operators` implemented in `SLOTH`.  <p>As illustrated in the figure 3, the specific operators are associated with <code>NonLinearFormIntegrators</code> which are used to compute the residual and the Jacobian contributions. They inherit from the <code>MFEM</code> <code>BlockNonlinearFormIntegrator</code> class. </p> <p>On the inheritance from <code>BlockNonlinearFormIntegrator</code> instead of <code>NonlinearFormIntegrator</code></p> <p>For <code>SLOTH</code> integrators, inheriting from <code>BlockNonlinearFormIntegrator</code> maximizes the generality of the implementation, as it allows solving both single-unknown problems and problems with several unknowns. </p> PhaseFieldOperatorDiffusionOperatorHeatOperator <p>This operator allows solving Cahn-Hilliard and Allen-Cahn problems.</p> <p><code>PhaseFieldOperator</code> is a template class instantiated with four template parameters: first, the kind of finite element, second, the spatial dimension, third the <code>NonlinearFormIntegrator</code> for the differential operators  (see GGG in the equation (1)) and fourth, the <code>NonlinearFormIntegrator</code> for the time derivative operator.  (see FFF in the equation (1)).</p> <p>Alias declaration for <code>PhaseFieldOperator</code> class template</p> <p>This example show how to define a convenient alias for the <code>PhaseFieldOperator</code> class template instantiated with <code>mfem::H1_FECollection</code> in dimension 3. </p> <p><code>NLFI</code> and <code>LHS_NLFI</code> corresponds to the <code>NonlinearFormIntegrator</code> objects for the differential operators and for the time derivative operator, respectively.  </p> <pre><code>using OPERATOR = PhaseFieldOperator&lt;mfem::H1_FECollection, 3, NLFI, LHS_NLFI&gt;;\n</code></pre> <p>The <code>OPERATOR</code> operator must be defined by:</p> <ul> <li>a vector of spatial discretisation objects (see Meshing), </li> <li>a set of parameters (see Parameters),</li> <li>a ODE solver for time stepping.</li> </ul> <p>On the size of the vector of spatial discretisation objects</p> <p>In <code>SLOTH</code>, each operator is designed to solve a system of PDEs with a monolithic algorithm. The size of the vector of spatial discretisation objects must be equal to the number of unknowns.</p> <p>The parameters allowed with <code>PhaseFieldOperator</code> are summarized in table 1.</p> Parameter Name Type Default Value Description <code>\"omega\"</code> <code>double</code> depth of the double-well potential <code>\"lambda\"</code> <code>double</code> energy gradient coefficient Table 1 - parameters allowed with <code>PhaseFieldOperator</code> <p>Regarding the time stepping, three ODE solvers have been integrated in <code>SLOTH</code> among those provided by <code>MFEM</code>:</p> <ul> <li>The backward Euler method  (<code>SLOTH</code> object <code>TimeScheme::EulerImplicit</code>),</li> <li>The forward Euler method  (<code>SLOTH</code> object <code>TimeScheme::EulerExplicit</code>),</li> <li>The Runge-Kutta 4 method (<code>SLOTH</code> object <code>TimeScheme::RungeKutta4</code>).</li> </ul> <p>Extension of the list of ODE solver in <code>SLOTH</code></p> <p><code>MFEM</code> provides several ODE solvers. To begin, <code>SLOTH</code>development team integrates the most common methods, namely Euler and Runge-Kutta 4 methods. </p> <p>In the future, this list could be extended to account for high order methods.</p> <p>Definition of a PhaseField operator</p> <p>This example assume a phase-field problem with two unknowns (<code>phi</code> and <code>mu</code>).  The <code>OPERATOR</code> object, denoted by <code>phasefield_ope</code>, is well declared with a vector of two spatial discretization objects, two <code>Parameter</code> objects and an Euler Implicit time-stepping method.</p> <pre><code>using OPERATOR = PhaseFieldOperator&lt;mfem::H1_FECollection, 3, NLFI, LHS_NLFI&gt;; \n\nconst double lambda(1.e-4);\nconst double omega(1.);\nauto phasefield_params = Parameters(Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));         \nauto phasefield_vars = Variables(phi, mu); \nstd::vector&lt;SPA*&gt; spatials{&amp;spatial, &amp;spatial};\nOPERATOR phasefield_ope(spatials, phasefield_params, TimeScheme::EulerImplicit);\n</code></pre> <p>The <code>NonlinearFormIntegrator</code> objects depend on the phase-field problem. Here, those currently used in <code>SLOTH</code> are described for Cahn-Hilliard and Allen-Cahn problems. </p> Cahn-Hilliard problemsAllen-Cahn problems <p>The Cahn-Hilliard problems solved in <code>SLOTH</code> can be expressed in the following form:</p> <p>\u2202\u03d5\u2202t=\u2207\u22c5[M(\u03d5)\u2207\u03bc]\u00a0in\u00a0\u03a9\u03bc=\u03c9F\u2032(\u03d5)\u2212\u2207\u22c5[\u03bb\u2207\u03d5]\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= \\nabla \\cdot \\left[M(\\phi) \\nabla \\mu\\right] \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= \\omega F'(\\phi) - \\nabla \\cdot \\left[\\lambda \\nabla \\phi\\right] \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=\u2207\u22c5[M(\u03d5)\u2207\u03bc]\u00a0in\u00a0\u03a9=\u03c9F\u2032(\u03d5)\u2212\u2207\u22c5[\u03bb\u2207\u03d5]\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of a potential FFF.</p> <p>The <code>NonlinearFormIntegrator</code> objects are:</p> <ul> <li><code>TimeCHNLFormIntegrator</code> for time derivative operator,</li> <li><code>CahnHilliardNLFormIntegrator</code> for differential opertors.</li> </ul> <p><code>TimeCHNLFormIntegrator</code> is a template class instantiated with a <code>Variables</code> object. </p> <p>Alias declaration for <code>TimeCHNLFormIntegrator</code> class template</p> <p>This example show how to define a convenient alias for the <code>TimeCHNLFormIntegrator</code> class template instantiated with a <code>Variables</code>object, which itself is instantiated with <code>mfem::H1_FECollection</code> in dimension 3. </p> <pre><code>using VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing LHS_NLFI = TimeCHNLFormIntegrator&lt;VARS&gt;;\n</code></pre> <p><code>CahnHilliardNLFormIntegrator</code> is a template class instantiated with a <code>Variables</code> object, a temporal scheme for the potential FFF, a type of potential and a type of mobility.</p> <p>Declaration of the potential and mobility coefficient</p> <p>The declaration of the three last template parameters will be simplified in a future version of <code>SLOTH</code>.  Waiting this evolution, <code>SLOTH</code> development team recommends:</p> <ul> <li><code>ThermodynamicsPotentialDiscretization::Implicit</code> for the temporal scheme for the potential FFF</li> <li><code>ThermodynamicsPotentials::F</code> for </li> </ul> <p>F(\u03d5)=\u03d544\u2212\u03d522  \\begin{align*}  F(\\phi)&amp;=\\frac{\\phi^4}{4} - \\frac{\\phi^2}{2} \\end{align*}  F(\u03d5)\u200b=4\u03d54\u200b\u22122\u03d52\u200b\u200b</p> <ul> <li><code>ThermodynamicsPotentials::W</code> for </li> </ul> <p>F(\u03d5)=\u03d52(1\u2212\u03d5)2  \\begin{align*}  F(\\phi)&amp;=\\phi^2 (1- \\phi)^2 \\end{align*}  F(\u03d5)\u200b=\u03d52(1\u2212\u03d5)2\u200b</p> <ul> <li><code>ThermodynamicsPotentials::WW</code> for </li> </ul> <p>F(\u03d5)=(\u03d5\u22120.3)2(0.7\u2212\u03d5)2  \\begin{align*}  F(\\phi)&amp;=(\\phi-0.3)^2 (0.7 - \\phi)^2 \\end{align*}  F(\u03d5)\u200b=(\u03d5\u22120.3)2(0.7\u2212\u03d5)2\u200b</p> <ul> <li><code>Mobility::Constant</code> for a constant mobility M(\u03d5)=MM(\\phi)=MM(\u03d5)=M</li> <li><code>Mobility::Degenerated</code> for a degenerated mobility defined by:</li> </ul> <p>M(\u03d5)=M\u03d5n(1\u2212\u03d5)n,n\u22650  \\begin{align*}  M(\\phi)&amp;=M \\phi^n (1-\\phi)^n, \\quad n\\geq0 \\end{align*}  M(\u03d5)\u200b=M\u03d5n(1\u2212\u03d5)n,n\u22650\u200b</p> <p>Alias declaration for <code>CahnHilliardNLFormIntegrator</code> class template</p> <p>This example show how to define a convenient alias for the <code>CahnHilliardNLFormIntegrator</code> class template instantiated with a <code>Variables</code>object, which itself is instantiated with <code>mfem::H1_FECollection</code> in dimension 3, a constant mobility, the potential <code>ThermodynamicsPotentials::F</code> discrtized with an implicit scheme.</p> <pre><code>using VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing NLFI = CahnHilliardNLFormIntegrator&lt;VARS, \n                                          ThermodynamicsPotentialDiscretization::Implicit,\n                                          ThermodynamicsPotentials::F, \n                                          Mobility::Constant&gt;;\n</code></pre> <p>The only parameter available for <code>CahnHilliardNLFormIntegrator</code> is given in the table 2.</p> Parameter Name Type Default Value Description <code>ScaleMobilityByTemperature</code> <code>bool</code> <code>false</code> flag to indicate if the mobility coefficient is divided by the temperature. In this case, temperature must be defined as auxiliary variables of the problem. Table 2 - parameters allowed with <code>CahnHilliardNLFormIntegrator</code> <p>Definition of a Cahn-Hilliard problem</p> <p>This example shows how to define a Cahn-Hilliard problem with two unknowns (<code>phi</code> and <code>mu</code>).</p> <pre><code>using PST = PostProcessing&lt;mfem::H1_FECollection, mfem::ParaviewDataCollection, 2&gt;;\nusing VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing LHS_NLFI = TimeCHNLFormIntegrator&lt;VARS&gt;;\nusing NLFI = CahnHilliardNLFormIntegrator&lt;VARS, \n                                          ThermodynamicsPotentialDiscretization::Implicit,\n                                          ThermodynamicsPotentials::F, \n                                          Mobility::Constant&gt;;\n\nusing OPERATOR = PhaseFieldOperator&lt;mfem::H1_FECollection, 3, NLFI, LHS_NLFI&gt;;          \nusing PB = Problem&lt;OPERATOR,VARS,PST&gt;;\n\nconst double mob(1.e-1);\nconst double lambda(1.e-4);\nconst double omega(1.);\nauto phasefield_params = Parameters(Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));         \nauto phasefield_vars = Variables(phi, mu); \nauto phasefield_pst = PST(&amp;spatial, pst_parameters);\n\nstd::vector&lt;SPA*&gt; spatials{&amp;spatial, &amp;spatial};\nOPERATOR phasefield_ope(spatials, params, TimeScheme::EulerImplicit);\nphasefield_ope.overload_mobility(Parameters(Parameter(\"mob\", mob)));\n\nPB phasefield_pb(phasefield_ope, phasefield_vars, phasefield_pst);\n</code></pre> <p>On the value of the mobility coefficient</p> <p>In addition to the example dedicted to the definition of the <code>PhaseFieldOperator</code>, it is important to note that the mobility coefficient is overloaded because by default, the mobility is set to 111. </p> <p>The Allen-Cahn problems solved in <code>SLOTH</code> can be expressed in the following form:</p> <p>\u2202\u03d5\u2202t=M(\u03d5)\u03bc+P(\u03d5)S\u00a0in\u00a0\u03a9\u03bc=\u2207\u22c5[\u03bb\u2207\u03d5]\u2212\u03c9F\u2032(\u03d5)\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= M(\\phi) \\mu + P(\\phi)\\mathcal{S} \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;=  \\nabla \\cdot \\left[\\lambda \\nabla \\phi\\right] - \\omega F'(\\phi)\\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=M(\u03d5)\u03bc+P(\u03d5)S\u00a0in\u00a0\u03a9=\u2207\u22c5[\u03bb\u2207\u03d5]\u2212\u03c9F\u2032(\u03d5)\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential, F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of a potential FFF, PPP an interpolation function and S\\mathcal{S}S a source term. </p> <p>The <code>NonlinearFormIntegrator</code> objects are:</p> <ul> <li><code>TimeNLFormIntegrator</code> for time derivative operator,</li> <li><code>AllenCahnNLFormIntegrator</code>, <code>AllenCahnCalphadMeltingNLFormIntegrator.hpp</code>, <code>AllenCahnConstantMeltingNLFormIntegrator.hpp</code> and <code>AllenCahnTemperatureMeltingNLFormIntegrator.hpp</code> for differential opertors.</li> </ul> <p><code>TimeNLFormIntegrator</code> is a template class instantiated with a <code>Variables</code> object. </p> <p>Alias declaration for <code>TimeNLFormIntegrator</code> class template</p> <p>This example show how to define a convenient alias for the <code>TimeNLFormIntegrator</code> class template instantiated with a <code>Variables</code>object, which itself is instantiated with <code>mfem::H1_FECollection</code> in dimension 3. </p> <pre><code>using VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing LHS_NLFI = TimeNLFormIntegrator&lt;VARS&gt;;\n</code></pre> <p><code>AllenCahnNLFormIntegrator</code> is a template class instantiated with a <code>Variables</code> object, a temporal scheme for the potential FFF, a type of potential and a type of mobility.</p> <p>Declaration of the potential and mobility coefficient</p> <p>The declaration of the three last template parameters will be simplified in a future version of <code>SLOTH</code>.  Waiting this evolution, <code>SLOTH</code> development team recommends:</p> <ul> <li><code>ThermodynamicsPotentialDiscretization::Implicit</code> for the temporal scheme for the potential FFF</li> <li><code>ThermodynamicsPotentials::F</code> for </li> </ul> <p>F(\u03d5)=\u03d544\u2212\u03d522  \\begin{align*}  F(\\phi)&amp;=\\frac{\\phi^4}{4} - \\frac{\\phi^2}{2} \\end{align*}  F(\u03d5)\u200b=4\u03d54\u200b\u22122\u03d52\u200b\u200b</p> <ul> <li><code>ThermodynamicsPotentials::W</code> for </li> </ul> <p>F(\u03d5)=\u03d52(1\u2212\u03d5)2  \\begin{align*}  F(\\phi)&amp;=\\phi^2 (1- \\phi)^2 \\end{align*}  F(\u03d5)\u200b=\u03d52(1\u2212\u03d5)2\u200b</p> <ul> <li><code>Mobility::Constant</code> for a constant mobility M(\u03d5)=MM(\\phi)=MM(\u03d5)=M</li> <li><code>Mobility::Degenerated</code> for a degenerated mobility defined by:</li> </ul> <p>M(\u03d5)=M\u03d5n(1\u2212\u03d5)n,n\u22650  \\begin{align*}  M(\\phi)&amp;=M \\phi^n (1-\\phi)^n, \\quad n\\geq0 \\end{align*}  M(\u03d5)\u200b=M\u03d5n(1\u2212\u03d5)n,n\u22650\u200b</p> <p>Alias declaration for <code>AllenCahnNLFormIntegrator</code> class template</p> <p>This example show how to define a convenient alias for the <code>AllenCahnNLFormIntegrator</code> class template instantiated with a <code>Variables</code>object, which itself is instantiated with <code>mfem::H1_FECollection</code> in dimension 3, a constant mobility, the potential <code>ThermodynamicsPotentials::W</code> discrtized with an implicit scheme.</p> <pre><code>using VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing NLFI = AllenCahnNLFormIntegrator&lt;VARS, \n                                          ThermodynamicsPotentialDiscretization::Implicit,\n                                          ThermodynamicsPotentials::W, \n                                          Mobility::Constant&gt;;\n</code></pre> <p>The only parameter available for <code>AllenCahnNLFormIntegrator</code> is given in the table 2.</p> Parameter Name Type Default Value Description <code>ScaleMobilityByTemperature</code> <code>bool</code> <code>false</code> flag to indicate if the mobility coefficient is divided by the temperature. In this case, temperature must be defined as auxiliary variables of the problem. Table 2 - parameters allowed with <code>AllenCahnNLFormIntegrator</code> <p>Definition of a Allen-Cahn problem</p> <p>This example shows how to define a Allen-Cahn problem with one unknown <code>phi</code>.</p> <pre><code>using PST = PostProcessing&lt;mfem::H1_FECollection, mfem::ParaviewDataCollection, 2&gt;;\nusing VARS = Variables&lt;mfem::H1_FECollection, 3&gt;\nusing LHS_NLFI = TimeNLFormIntegrator&lt;VARS&gt;;\nusing NLFI = AllenCahnNLFormIntegrator&lt;VARS, \n                                          ThermodynamicsPotentialDiscretization::Implicit,\n                                          ThermodynamicsPotentials::W, \n                                          Mobility::Constant&gt;;\n\nusing OPERATOR = PhaseFieldOperator&lt;mfem::H1_FECollection, 3, NLFI, LHS_NLFI&gt;;          \nusing PB = Problem&lt;OPERATOR,VARS,PST&gt;;\n\nconst double mob(1.e-1);\nconst double lambda(1.e-4);\nconst double omega(1.);\nauto phasefield_params = Parameters(Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));         \nauto phasefield_vars = Variables(phi); \nauto phasefield_pst = PST(&amp;spatial, pst_parameters);\n\nstd::vector&lt;SPA*&gt; spatials{&amp;spatial};\nOPERATOR phasefield_ope(spatials, params, TimeScheme::EulerImplicit);\nphasefield_ope.overload_mobility(Parameters(Parameter(\"mob\", mob)));\n\nPB phasefield_pb(phasefield_ope, phasefield_vars, phasefield_pst);\n</code></pre> <p>On the value of the mobility coefficient</p> <p>In addition to the example dedicted to the definition of the <code>PhaseFieldOperator</code>, it is important to note that the mobility coefficient is overloaded because by default, the mobility is set to 111. </p> <p><code>AllenCahnCalphadMeltingNLFormIntegrator.hpp</code>, <code>AllenCahnConstantMeltingNLFormIntegrator.hpp</code> and <code>AllenCahnTemperatureMeltingNLFormIntegrator.hpp</code> are dedicated to multiphysics simulations with melting. These integrators are template classes similar to <code>AllenCahnNLFormIntegrator.hpp</code> but intanciated with an additional template parameter, the interpolation function (see P(\u03d5)P(\\phi)P(\u03d5) in the equation 2.)</p> <p>Declaration of the interpolation function</p> <p>The declaration of the interpolation function will be simplified in a future version of <code>SLOTH</code>.  Waiting this evolution, <code>SLOTH</code> development team recommends:</p> <ul> <li><code>ThermodynamicsPotentials::H</code> for </li> </ul> <p>P(\u03d5)=\u03d53(6\u03d52\u221215\u03d5+10)  \\begin{align*}  P(\\phi)&amp;=\\phi^3  (6 \\phi^2 - 15 \\phi + 10) \\end{align*}  P(\u03d5)\u200b=\u03d53(6\u03d52\u221215\u03d5+10)\u200b</p> <ul> <li><code>ThermodynamicsPotentials::X</code> for </li> </ul> <p>P(\u03d5)=\u03d5  \\begin{align*}  P(\\phi)&amp;=\\phi \\end{align*}  P(\u03d5)\u200b=\u03d5\u200b</p> <code>AllenCahnConstantMeltingNLFormIntegrator.hpp</code><code>AllenCahnTemperatureMeltingNLFormIntegrator.hpp</code><code>AllenCahnCalphadMeltingNLFormIntegrator.hpp</code> <p>For this integrator, the source term is a constant defined by the <code>Parameter</code> of type <code>double</code> and named <code>melting_factor</code>.</p> <p>This integrator is only used for test. </p> <p>For this integrator, the source term S\\mathcal{S}S is defined by:        <p>S={Hmif\u00a0T&gt;Tm,0if\u00a0T\u2264Tm  \\begin{align*}   \\mathcal{S}&amp;= \\begin{cases} H_m &amp; \\text{if } T &gt; T_m, \\\\ 0  &amp; \\text{if } T \\leq T_m \\end{cases}  \\end{align*}  S\u200b={Hm\u200b0\u200bif\u00a0T&gt;Tm\u200b,if\u00a0T\u2264Tm\u200b\u200b\u200b</p> where TmT_mTm\u200b and HmH_mHm\u200b are the melting temperature and the melting enthalpy, respectively. Both are defined by the parameters listed in table 3.</p> Parameter Name Type Default Value Description <code>melting_temperature</code> <code>double</code> melting temperature <code>melting_enthalpy</code> <code>double</code> melting enthalpy Table 3 - parameters allowed with <code>AllenCahnTemperatureMeltingNLFormIntegrator</code> <p>In this case, temperature must be defined as auxiliary variables of the problem. </p> <p>This integrator must be used for CALPHAD-informed phase-field simulation<sup>1</sup>. </p> Parameter Name Type Default Value Description <code>primary_phase</code> <code>std::string</code> name of the phase before melting <code>secondary_phase</code> <code>std::string</code> name of the phase after melting Table 3 - parameters allowed with <code>AllenCahnCalphadMeltingNLFormIntegrator</code> <p>In this case, the CALPHAD outputs -driving forces and nucleus- must be defined as auxiliary variables of the phase-field problem.</p> <p>(Coming soon)</p> <p>(Coming soon)</p> <ol> <li> <p>Cl\u00e9ment Intro\u00efni, J\u00e9r\u00f4me Sercombe, Isabelle Rami\u00e8re, and Romain Le Tellier. Phase-field modeling with the taf-id of incipient melting and oxygen transport in nuclear fuel during power transients. Journal of Nuclear Materials, 556:153173, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Problems/Remainder/index.html","title":"\"The remainder\"","text":"<p>\"The remainder\" refers to everything that is neither PDEs nor 0D problems, such as the computation of physical properties or the update of variables (e.g. c\u223cf(\u03bc)c\\sim f(\\mu)c\u223cf(\u03bc) in the grand potential formulation of phase-field model).</p> <p>The <code>SLOTH</code> development team recommends using <code>Property_problem</code>.  This is a template class instantiated with three template parameters: first, an <code>PROPERTY</code> object, second, the <code>Variables</code> object (see <code>VARS</code>in the example), and third, the <code>Postprocessing</code> object (see <code>PST</code> in the example).</p> <p>Alias declaration for <code>Property_problem</code> class template</p> <pre><code>using PropertyProblem = PropertyProblem&lt;PROPERTY, VARS, PST&gt;;\n</code></pre> <p>The users are referred to dedicated pages of the user manual for details about Variables and PostProcessing.</p> <p>The <code>PROPERTY</code> object in <code>Property_problem</code> corresponds to a C++ object that inherits from the template class <code>PropertyBase</code>, only defined with a set of <code>Parameter</code> (within a <code>Parameters</code> object).</p> <p>Similar to other types of problems,  <code>Property_problem</code> take auxiliary <code>Variables</code> as inputs, and primary <code>Variables</code> as outputs.</p> <p>Defintion of a fictitious <code>Property_problem</code></p> <pre><code>auto property_params = FictitiousProperty(property_params);\nusing PropertyProblem = PropertyProblem&lt;FictitiousProperty, VARS, PST&gt;;\n\nPropertyProblem prop_pb = fictitious_property_problem(\n  \"Property problem\", property_params, outputs_property_var, inputs_property_var);\n</code></pre>"},{"location":"Documentation/User/MultiPhysicsCouplingScheme/Time/index.html","title":"Time discretization","text":"<p>This page describes the C++ object <code>TimeDiscretization</code>, which enables <code>SLOTH</code> to manage the time loop of all multiphysics simulations.</p> <p><code>TimeDiscretization</code> object is simply defined by:</p> <ul> <li>a list of parameters (<code>SLOTH</code> object <code>Parameters</code>)</li> <li>a list of <code>Coupling</code></li> </ul> <p>The parameters allowed with <code>TimeDiscretization</code> are summarized in table 1.</p> Object Parameter Name Type Default Value Description <code>TimeDiscretization</code> <code>\"initial_time\"</code> <code>double</code> <code>0.</code> The initial time of the simulation <code>TimeDiscretization</code> <code>\"final_time\"</code> <code>double</code> The final time of the simulation <code>TimeDiscretization</code> <code>\"time_step\"</code> <code>double</code> The time-step of the simulation Table 1 - parameters allowed with <code>TimeDiscretization</code> <p>On the time-step</p> <ul> <li>The time-step is currently constant. Adaptative time-stepping will be implemented in the future. </li> </ul> <p>Example of <code>TimeDiscretization</code> with parameters</p> <p>The following example assume a multiphysics simulation based on two couplings, each composed of three problems. </p> <p>The time loop starts at 000 s, ends at 111 s with a time-step of 0.10.10.1 s.</p> <pre><code>    auto coupling_example_1 = Coupling(\"MyCoupling1\", Problem1_1, Problem1_2, Problem1_3);\n    auto coupling_example_2 = Coupling(\"MyCoupling2\", Problem2_1, Problem2_2, Problem2_3);\n\n    const double t_initial = 0.0;\n    const double t_final = 1.0;\n    const double dt = 0.1;\n    auto time_params = Parameters(\n        Parameter(\"initial_time\", t_initial),\n        Parameter(\"final_time\", t_final), \n        Parameter(\"time_step\", dt));\n    auto time = TimeDiscretization(time_parameters, coupling_example_1, coupling_example_2);\n</code></pre>"},{"location":"Documentation/User/Parameters/index.html","title":"Parameters","text":"<p>This page focuses on the <code>Parameter</code> and <code>Parameter</code> objects specially designed for <code>SLOTH</code>.</p> <p><code>SLOTH</code> provides a variety of parameter types, enabling flexible and dynamic configuration of simulation inputs. These parameters can then be passed as arguments to <code>SLOTH</code> problems (see Problems for more details).</p>"},{"location":"Documentation/User/Parameters/index.html#param","title":"Parameter","text":"<p>Each parameter is managed by the C++ class <code>Parameter</code>.  A Parameter is defined by its name (type <code>std::string</code>), its value, and optionally a description (type <code>std::string</code>). </p> <pre><code>Parameter(name, value, description)\n\nParameter(name, value)\n</code></pre> <p>The type of the <code>Parameter</code>is deduced from the value.  The basic types <code>double</code>, <code>int</code>, <code>std::string</code> and <code>bool</code> can be used </p> <p>Example of definitions of Parameter with basic types</p> doubleintstd::stringbool <pre><code>Parameter(\"p1\", 1.0, \"Scalar Parameter of type double\")\n</code></pre> <pre><code>Parameter(\"p1\", 1, \"Scalar Parameter of type int\")\n</code></pre> <pre><code>Parameter(\"p1\", \"1.0\", \"Scalar Parameter of type std::string\")\n</code></pre> <pre><code>Parameter(\"p1\", true, \"Scalar Parameter of type bool\")\n</code></pre> <p>but also custom-defined containers:</p> <p>Example of definitions of Parameter with custom-defined  types</p> <p>Custom-defined types can be defined either by their standard definition or by using a C++ alias.</p> MapStringDoubleMap2String2DoublevStringvIntvDoublevTupleStringIntvTupleStringStringvTuple2StringDouble <p><code>MapStringDouble</code>is a C++ alias for <code>std::map&lt;std::string,double&gt;</code>.</p> <pre><code>MapStringDouble param_value;\nparam_value.emplace(\"value\", 1.0);\nParameter(\"p1\", param_value, \"Scalar Parameter of type MapStringDouble\")\n</code></pre> <p><code>Map2String2Double</code>is a C++ alias for <code>std::map&lt;std::tuple&lt;std::string, std::string&gt;, std::tuple&lt;double, double&gt;&gt;</code>.</p> <pre><code>Map2String2Double param_value;\nparam_value.emplace(std::make_tuple(\"value_1\", \"value_2\"), std::make_tuple(1.0,2.));\nParameter(\"p1\", param_value, \"Scalar Parameter of type Map2String2Double\")\n</code></pre> <p><code>vString</code>is a C++ alias for <code>std::vector&lt;std::string&gt;</code>.</p> <pre><code>vString param_value;\nparam_value.emplace_back(\"value_1\");\nparam_value.emplace_back(\"value_2\");\nParameter(\"p1\", param_value, \"Scalar Parameter of type vString\")\n</code></pre> <p><code>vInt</code>is a C++ alias for <code>std::vector&lt;int&gt;</code>.</p> <pre><code>vInt param_value;\nparam_value.emplace_back(0);\nparam_value.emplace_back(1);\nParameter(\"p1\", param_value, \"Scalar Parameter of type vInt\")\n</code></pre> <p><code>vDouble</code>is a C++ alias for <code>std::vector&lt;double&gt;</code>.</p> <pre><code>vDouble param_value;\nparam_value.emplace_back(0.0);\nparam_value.emplace_back(0.1);\nParameter(\"p1\", param_value, \"Scalar Parameter of type vDouble\")\n</code></pre> <p><code>vString</code>is a C++ alias for <code>std::vector&lt;std::tuple&lt;std::string,int&gt;&gt;</code>.</p> <pre><code>vTupleStringInt param_value;\nparam_value.emplace_back(std::make_tuple(\"value_1\",1));\nparam_value.emplace_back(std::make_tuple(\"value_2\",2));\nParameter(\"p1\", param_value, \"Scalar Parameter of type vTupleStringInt\")\n</code></pre> <p><code>vTupleStringString</code>is a C++ alias for <code>std::vector&lt;std::tuple&lt;std::string,std::string&gt;&gt;</code>.</p> <pre><code>vTupleStringString param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\"));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\"));\nParameter(\"p1\", param_value, \"Scalar Parameter of type vTupleStringString\")\n</code></pre> <p><code>vTuple2StringDouble</code>is a C++ alias for <code>std::vector&lt;std::tuple&lt;std::string,std::string, double&gt;&gt;</code>.</p> <pre><code>vTuple2StringDouble param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\",0.0));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\",1.0));\nParameter(\"p1\", param_value, \"Scalar Parameter of type vTuple2StringDouble\")\n</code></pre> <p>This list of parameter types can be easly extended.</p> <p>Access to <code>Parameter</code> informations</p> <p>As for deep inside the code, C++ public methods allow you to get the name, description and value of a `parameter'. </p> <p>Please see the Doxygen for more details.</p>"},{"location":"Documentation/User/Parameters/index.html#params","title":"Parameters","text":"<p>The C++ class <code>Parameters</code> allows to define a collection of <code>Parameter</code> objects of different types. </p> <p>Example of definitions of Parameters</p> <pre><code>auto p1 = Parameter(\"p1\", 1.0, \"Scalar Parameter of type double\")\nauto p2 = Parameter(\"p2\", true, \"Scalar Parameter of type bool\")\nvTupleStringString param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\"));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\"));\nauto p3 = Parameter(\"p3\", param_value, \"Scalar Parameter of type vTupleStringString\")\n\nauto params = Parameters(p1, p2, p3);\n</code></pre> <p>In this example, <code>params</code> gathers three <code>Parameter</code> of type <code>double</code>, <code>bool</code> and <code>vTupleStringString</code>.</p> <p><code>Parameters</code> class allows to add or substract <code>Parameter</code>.</p>"},{"location":"Documentation/User/Parameters/index.html#addition-of-parameters","title":"Addition of parameters","text":"<p>Two `Parameters' objects can be merged.</p> <p>Example of merge of two Parameters</p> <pre><code>auto p1 = Parameter(\"p1\", 1.0, \"Scalar Parameter of type double\")\nauto p2 = Parameter(\"p2\", true, \"Scalar Parameter of type bool\")\nvTupleStringString param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\"));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\"));\nauto p3 = Parameter(\"p3\", param_value, \"Scalar Parameter of type vTupleStringString\")\n\nauto merge_parameter = Parameters(p1) + Parameters(p2, p3);\n</code></pre> <p>Priority when merging</p> <p>When merging two <code>Parameters' objects, any</code>Parameter' contained in the second <code>Parameter' will overwrite any</code>Parameter' contained in the first `Parameter' if they have the same name.</p> <p>A <code>Parameters' can be also be merged with a</code>Parameter' object. </p> <p>Example of merge of a Parameters with a Parameter</p> <pre><code>auto p1 = Parameter(\"p1\", 1.0, \"Scalar Parameter of type double\")\nauto p2 = Parameter(\"p2\", true, \"Scalar Parameter of type bool\")\nvTupleStringString param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\"));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\"));\nauto p3 = Parameter(\"p3\", param_value, \"Scalar Parameter of type vTupleStringString\")\n\nauto merge_parameter = Parameters(p2, p3) + p1 ;\n</code></pre> <p>Priority when merging</p> <p>If the <code>Parameter' object already contains a</code>Parameter' with the same name as the `Parameter' to be merged, the latter will overwrite the existing one.</p>"},{"location":"Documentation/User/Parameters/index.html#removing-a-parameter","title":"Removing a parameter","text":"<p>A <code>Parameter' can be removed from a</code>Parameters' object by name.</p> <p>Example of <code>Parameter</code> removal</p> <pre><code>auto p1 = Parameter(\"p1\", 1.0, \"Scalar Parameter of type double\")\nauto p2 = Parameter(\"p2\", true, \"Scalar Parameter of type bool\")\nvTupleStringString param_value;\nparam_value.emplace_back(std::make_tuple(\"key_1\",\"value_1\"));\nparam_value.emplace_back(std::make_tuple(\"key_2\",\"value_2\"));\nauto p3 = Parameter(\"p3\", param_value, \"Scalar Parameter of type vTupleStringString\")\n\nauto merge_parameter = Parameters(p1, p2, p3);\nauto reduced_parameter = merge_parameter - p1;\n</code></pre>"},{"location":"Documentation/User/PostProcessing/index.html","title":"Post-Processing","text":"<p>This page presents all Post-processing features and describes all parameters with default values.</p> <p>Definition of a post-processing for <code>SLOTH</code> is made with a C++ object of type <code>PostProcessing</code>.</p> <p><code>PostProcessing</code> is a template class instantiated with three template parameters: first, the kind of finite element, second the data format for saving results, and third, the spatial dimension.</p> <p>The kind of finite element refers to a C++ class that inherits from the <code>mfem::FiniteElementCollection</code>. This class manages all collections of finite elements provided by <code>MFEM</code>. Currently, the most commonly used finite element collection in <code>SLOTH</code> is <code>mfem::H1_FECollection</code>, which corresponds to arbitrary order H1-conforming continuous finite elements.</p> <p>The dimension is simply an integer that can be 1, 2, or 3.</p> <p>The data format refers to a C++ class that inherits from the <code>mfem::DataCollection</code>.  This class manages all collections of data provided by <code>MFEM</code>. The development team primarily uses <code>ParaView</code> to visualize results, which corresponds to the <code>mfem::ParaviewDataCollection</code> C++ class.</p> <p>Use of alternative software for visualizing results</p> <p>Users are free to employ alternative visualization software such as <code>Visit</code>. In that case, please contact the development team so that an interface to the <code>mfem::VisitDataCollection</code> class can be provided.</p> <p>Alias declaration for <code>PostProcessing</code> class template</p> <p><pre><code>using PST = PostProcessing&lt;mfem::H1_FECollection, mfem::ParaviewDataCollection, 2&gt;;\n</code></pre> This example show how to define a convenient alias for the <code>PostProcessing</code> class template instantiated with <code>mfem::H1_FECollection</code> and <code>mfem::ParaviewDataCollection</code> in dimension 2. </p> <p>Without loss of generality, the alias <code>PST</code> is used in this page in order to simplify each code snippet.</p> <p>The <code>PST</code> object must be defined by:</p> <ul> <li>the spatial discretisation (see Meshing), </li> <li>a set of parameters (see Parameters).</li> </ul> <p>Declaration of a <code>PostProcessing</code> object</p> <p><pre><code>auto post_processing = PST(&amp;spatial, pst_parameters);\n</code></pre> This example show how to declare an object <code>PST</code> with the spatial discretisation <code>spatial</code> and the paramters <code>pst_parameters</code>. </p> <p>Each <code>PST</code> object is associated with a <code>Problem</code> and its <code>Variables</code> are saved in <code>Paraview</code> file.</p> <p>The parameters allowed with <code>PostProcessing</code> for visualizing data with <code>Paraview</code> are summarized in table 1.</p> Parameter Name Type Default Value Description <code>\"main_folder_path\"</code> <code>std::string</code> root directory for saving all results <code>\"calculation_path\"</code> <code>std::string</code> directory for saving results of the problem <code>\"force_clean_output_dir\"</code> <code>bool</code> <code>false</code> flag to force cleaning of the root directory <code>\"frequency\"</code> <code>int</code> data output frequency <code>\"iterations_list\"</code> <code>std::vector&lt;int&gt;</code> Iteration indices for data output. Only if frequency is not provided. <code>\"times_list\"</code> <code>std::vector&lt;double&gt;</code> Times for data output. Only if <code>\"frequency\"</code> is not provided. Can be combined with <code>\"iterations_list\"</code> Table 1 - parameters allowed with <code>PostProcessing</code> for visualizing data with <code>Paraview</code> <p>In addition to visualizing <code>Variables</code> with <code>ParaView</code>, some results can also be exported in <code>CSV</code> files format.  </p> <p>The <code>time_specialized.csv</code> file contains:</p> <ul> <li>The L2^22 and L\u221e^\\infty\u221e norms of the error for each variable with an analytical solution,</li> <li>The energy density of the problem,</li> <li>The surface tension of the problem (for phase-field problems), </li> <li>The spatial average of the variable over the computational domain (if requested with the <code>integral_to_compute</code> parameter).</li> </ul> <p>The parameters allowed with <code>PostProcessing</code> for exporting specialized values in the <code>time_specialized.csv</code> file are summarized in table 2.</p> Parameter Name Type Default Value Description <code>\"enable_save_specialized_at_iter\"</code> <code>bool</code> false By default, specialized values are written at end of the simulation. This flag enables to write the values at each time-step. <code>\"iso_val_to_compute\"</code> <code>MapStringDouble</code> Map of isovalue for each variable. The key must match with the name of a <code>Variable</code>. <code>\"integral_to_compute\"</code> <code>MapString2Double</code> Map of lower and upper bounds used to compute the average value of each variable. The key must match with the name of a <code>Variable</code>. Table 2 - parameters allowed with <code>PostProcessing</code> to save specialized values in the <code>time_specialized.csv</code> file. <p>Isovalues are not stored in the <code>time_specialized.csv</code> file. Instead, the parameter <code>\"iso_val_to_compute\"</code> generates separate <code>CSV</code> files, one for each variable.</p> <p>On the dimension of <code>\"iso_val_to_compute\"</code> and <code>\"integral_to_compute\"</code> </p> <p>Parameters <code>\"iso_val_to_compute\"</code> and <code>\"integral_to_compute\"</code> must have exactly the dimension equalt to the  number of variables.</p> <p>On the lower and upper bounds used with <code>\"integral_to_compute\"</code> </p> <p>Lower and upper bounds are used to limit the calculation of the integral to specific values of the variables. For example, it can be usefull to compute the volume of a bubble that corresponds to a phase indicator lower than 0.50.50.5. </p> <p>Example of <code>PostProcessing</code> with parameters</p> <p>The following example assume the existence of a <code>Variable</code> named <code>\"phi\"</code> for Cahn-Hilliard equations. </p> <p>The results are saved in the <code>Saves/CahnHilliard</code> directory, at each time-step (see <code>frequency</code>).  </p> <p>Specialized values are also written at each time-step with the average value of <code>\"phi\"</code>.</p> <pre><code>    const std::string&amp; main_folder_path = \"Saves\";\n    const std::string&amp; calculation_path = \"CahnHilliard\";\n    const int frequency = 1;\n    std::map&lt;std::string, std::tuple&lt;double, double&gt;&gt; map_threshold_integral = { {\"phi\", {-1.1, 1.1}} };\n    bool save_specialized_at_iter = true;\n    auto pst_parameters = Parameters(\n        Parameter(\"main_folder_path\", main_folder_path),\n        Parameter(\"calculation_path\", calculation_path), \n        Parameter(\"frequency\", frequency),\n        Parameter(\"integral_to_compute\", map_threshold_integral),\n        Parameter(\"enable_save_specialized_at_iter\", save_specialized_at_iter));\n\n    auto post_processing = PST(&amp;spatial, pst_parameters);\n</code></pre>"},{"location":"Documentation/User/Profiling/index.html","title":"Profiling tools","text":"<p>This page describes how to define and use profiling tools in <code>SLOTH</code>.</p>"},{"location":"Documentation/User/Profiling/index.html#matools-and-timetable","title":"MATools and Timetable","text":"<p><code>SLOTH</code> provides a simple tool for profiling your application, consisting mainly in generating a time table of timed sections respecting the call stack (tree). The master or root timer of the call stack is initialized during the general initialization of <code>SLOTH</code>:</p> <pre><code>Profiling::getInstance().enable();\n</code></pre> <p>Displaying the time table in your terminal is done by adding the following function call:</p> <pre><code>Profiling::getInstance().print();\n</code></pre> <p>This is an example of an output:</p> <pre><code> |-- start timetable ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n |    name                                                         |    number Of calls |            min (s) |           mean (s) |            max (s) |     time ratio (%) |            imb (%) |\n |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n | &gt; root                                                          |                  1 |        3015.706043 |        3015.707311 |        3015.719556 |        100.000000% |          0.000004% |\n | |--&gt; TimeDiscretization::solve                                  |                  1 |        3006.454515 |        3006.499169 |        3006.514615 |         99.694768% |          0.000005% |\n |    |--&gt; TimeDiscretization::initialize                          |                  1 |           1.337877 |           1.387066 |           1.446550 |          0.047967% |          0.042885% |\n |       |--&gt; TransientOperatorBase::initialize                    |                  1 |           0.012189 |           0.035772 |           0.057620 |          0.001911% |          0.610737% |\n |          |--&gt; OperatorBase::initialize                          |                  1 |           0.012165 |           0.035724 |           0.057590 |          0.001910% |          0.612094% |\n |             |--&gt; TransientOperatorBase::SetConstantParameters   |                  1 |           0.000000 |           0.000000 |           0.000001 |          0.000000% |          6.579285% |\n |             |--&gt; TransientOperatorBase::SetTransientParameters  |                  1 |           0.009911 |           0.021716 |           0.053118 |          0.001761% |          1.446057% |\n |                |--&gt; TransientOperatorBase::set_lhs_nlfi_ptr     |                  1 |           0.000923 |           0.012096 |           0.043902 |          0.001456% |          2.629576% |\n |                |--&gt; PhaseFieldOperatorBase::set_nlfi_ptr        |                  1 |           0.001138 |           0.002769 |           0.041996 |          0.001393% |         14.168506% |\n |    |--&gt; TimeDiscretization::execute                             |                  5 |        2993.291732 |        2993.350153 |        2993.424353 |         99.260700% |          0.000025% |\n |       |--&gt; TransientOperatorBase::ImplicitSolve                 |                  5 |        2992.947524 |        2993.156591 |        2993.298005 |         99.256511% |          0.000047% |\n |          |--&gt; ImplicitSolve::SetTransientParams                 |                  5 |           0.198547 |           0.311298 |           0.432207 |          0.014332% |          0.388404% |\n |             |--&gt; TransientOperatorBase::SetTransientParameters  |                  5 |           0.196302 |           0.308663 |           0.429874 |          0.014254% |          0.392695% |\n |                |--&gt; TransientOperatorBase::set_lhs_nlfi_ptr     |                  5 |           0.009804 |           0.047970 |           0.084297 |          0.002795% |          0.757307% |\n |                |--&gt; PhaseFieldOperatorBase::set_nlfi_ptr        |                  5 |           0.010071 |           0.060219 |           0.104795 |          0.003475% |          0.740241% |\n |          |--&gt; ImplicitSolve::ApplyBCs                           |                  5 |           0.000004 |           0.000006 |           0.000013 |          0.000000% |          1.244960% |\n |          |--&gt; ImplicitSolve::SourceTerm                         |                  5 |           0.000000 |           0.000001 |           0.000003 |          0.000000% |          2.490184% |\n |          |--&gt; ImplicitSolve::CallMult                           |                  5 |        2992.620216 |        2992.843753 |        2992.999037 |         99.246597% |          0.000052% |\n |    |--&gt; TimeDiscretization::post_execute                        |                  5 |           0.000001 |           0.000002 |           0.000042 |          0.000001% |         19.698843% |\n |    |--&gt; TimeDiscretization::update                              |                  5 |           0.000000 |           0.000000 |           0.000000 |          0.000000% |          1.425799% |\n |    |--&gt; TimeDiscretization::post_processing                     |                  5 |          11.734255 |          11.761845 |          11.840706 |          0.392633% |          0.006705% |\n |       |--&gt; OperatorBase::ComputeIntegral                        |                  5 |           3.014340 |           3.045018 |           3.093798 |          0.102589% |          0.016020% |\n |       |--&gt; PhaseFieldOperatorBase::ComputeEnergies              |                  5 |           8.669824 |           8.672591 |           8.675049 |          0.287661% |          0.000283% |\n |    |--&gt; TimeDiscretization::finalize                            |                  1 |           0.000000 |           0.000001 |           0.000020 |          0.000001% |         16.281114% |\n |-- end timetable ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n</code></pre> <p>A file is also created: <code>MATimers.#mpi.perf</code>. Each line is composed of the section name, number of calls, time in seconds, and ratio to total time. This is an example of an output:</p> <pre><code>root 1 3015.72 100\n   TimeDiscretization::solve 1 3006.51 99.6948\n      TimeDiscretization::initialize 1 1.44655 0.047967\n         TransientOperatorBase::initialize 1 0.05762 0.00191066\n            OperatorBase::initialize 1 0.0575904 0.00190967\n               TransientOperatorBase::SetConstantParameters 1 5.9e-07 1.95642e-08\n               TransientOperatorBase::SetTransientParameters 1 0.0531182 0.00176138\n                  TransientOperatorBase::set_lhs_nlfi_ptr 1 0.0439016 0.00145576\n                  PhaseFieldOperatorBase::set_nlfi_ptr 1 0.0419957 0.00139256\n      TimeDiscretization::execute 5 2993.42 99.2607\n         TransientOperatorBase::ImplicitSolve 5 2993.3 99.2565\n            ImplicitSolve::SetTransientParams 5 0.432207 0.0143318\n               TransientOperatorBase::SetTransientParameters 5 0.429874 0.0142544\n                  TransientOperatorBase::set_lhs_nlfi_ptr 5 0.0842972 0.00279526\n                  PhaseFieldOperatorBase::set_nlfi_ptr 5 0.104795 0.00347495\n            ImplicitSolve::ApplyBCs 5 1.313e-05 4.35385e-07\n            ImplicitSolve::SourceTerm 5 2.8e-06 9.28468e-08\n            ImplicitSolve::CallMult 5 2993 99.2466\n      TimeDiscretization::post_execute 5 4.229e-05 1.40232e-06\n      TimeDiscretization::update 5 4.19e-07 1.38939e-08\n      TimeDiscretization::post_processing 5 11.8407 0.392633\n         OperatorBase::ComputeIntegral 5 3.0938 0.102589\n         PhaseFieldOperatorBase::ComputeEnergies 5 8.67505 0.287661\n      TimeDiscretization::finalize 1 1.977e-05 6.55565e-07\n</code></pre> <p>To disable the timetable or the file generation, you can use:</p> <pre><code>Profiling::getInstance().disable_timetable();\nProfiling::getInstance().disable_write_file();\n</code></pre> <p>You can instrument each of your functions using section timers. It's important to remember that adding chronos can add extra cost, negligible for \"big\" functions but very costly for functions called in each element.</p> <p>To time a function, place this instruction at the start of your function, the timer will stop at the end of the scope (the second time point is hidden in the timer destructor).</p> <pre><code>Catch_Time_Section(\"NameOfYourFunction\");\n</code></pre> <p>To add a second timer to the same scope, you can use:</p> <pre><code>Catch_Nested_Time_Section(\"NameOfYourNestedSection\");\n</code></pre> <p>To capture a specific section:</p> <pre><code>add_capture_chrono_section(\"NameOfYourSection\", [&amp;] {\n  your_code ...\n});\n</code></pre>"},{"location":"Documentation/User/SpatialDiscretization/index.html","title":"Spatial Discretization","text":"<p><code>SLOTH</code> uses the Finite Elements Method<sup>1</sup> <sup>2</sup>. </p> <p>On this page, the users can find instructions </p> <ul> <li>for building a finite element mesh on the basis of MFEM features,</li> <li>for prescribing boundary conditions. </li> </ul> <p>On the future use of <code>MEROPE</code> to generate microstructure meshes</p> <p><code>SLOTH</code> can read <code>GMSH</code> meshes and can therefore use microstructural meshes generated by the dedicated <code>MEROPE</code> code of the <code>PLEIADES</code> platform <sup>3</sup>.</p> <p>Ongoing work aims to provide a comprehensive study based on these real microstructural meshes.</p> <ol> <li> <p>Olgierd C Zienkiewicz and Robert Leroy Taylor. The finite element method set. Elsevier, 2005.\u00a0\u21a9</p> </li> <li> <p>Andr\u00e9 Fortin and Andr\u00e9 Garon. Les \u00e9l\u00e9ments finis: de la th\u00e9orie \u00e0 la pratique. Universit\u00e9 Laval, 2011.\u00a0\u21a9</p> </li> <li> <p>Marc Josien. M\u00e9rope: a microstructure generator for simulation of heterogeneous materials. Journal of Computational Science, 81:102359, 2024. URL: https://www.sciencedirect.com/science/article/pii/S1877750324001522, doi:https://doi.org/10.1016/j.jocs.2024.102359.\u00a0\u21a9</p> </li> </ol>"},{"location":"Documentation/User/SpatialDiscretization/BoundaryConditions/index.html","title":"Boundary Conditions","text":"<p>This page described the definition and the use of boundary conditions in <code>SLOTH</code>.</p> <p>Definition of boundary conditions for <code>SLOTH</code> is made with a C++ object of type <code>BoundaryConditions</code>. As for the object <code>SpatialDiscretization</code> (see Meshing), <code>BoundaryConditions</code> is a template class instantiated with two template parameters: first, the kind of finite element, and second, the spatial dimension. </p> <p>Currently, the most commonly used finite element collection in <code>SLOTH</code> is <code>mfem::H1_FECollection</code>, which corresponds to arbitrary order H1-conforming continuous finite elements.</p> <p>The dimension is simply an integer that can be 1, 2, or 3.</p> <p>Alias declaration for <code>BoundaryConditions</code> class template</p> <p><pre><code>using BCS = BoundaryConditions&lt;mfem::H1_FECollection, 3&gt;;\n</code></pre> This example show how to define a convenient alias for the <code>BoundaryConditions</code> class template instantiated with <code>mfem::H1_FECollection</code> in dimension 3. This alias is often used in tests in order to simplify the code.</p> <p><code>BoundaryConditions</code> is roughly defined as a set of C++ object of type <code>Boundary</code>.  Each geometrical boundary must be associated with a C++ object of type <code>Boundary</code>.</p> <p>Number of boundaries</p> <p>The number of <code>Boundary</code> objects inside the <code>Boundaries</code> object must be equal to the total number of geometrical boundary. </p> <p>A <code>Boundary</code> object is defined by</p> <ul> <li>a name (C++ type `std::string'),</li> <li>an index (C++ type <code>int</code>),</li> <li>a type (C++ type `std::string') among \"Dirichlet\", \"Neumann\", \"Periodic\",</li> <li>a value (C++ type <code>double</code>), equal to zero by default.</li> </ul> <p>Consistency of the indices of the boundaries</p> <p><code>MFEM v4.7</code> provides new features for referring to boundary attribute numbers. Such an improvement is not yet implemented in <code>SLOTH</code>. Consequently, users must take care to the consistency of the indices used in the test file with the indices defined when building the mesh with <code>GMSH</code>.</p> <p>Defining boundary conditions</p> <p>The following examples assume that the spatial discretisation is defined.  In the code snippets, it is referred to as a <code>spatial</code> object.</p> <p>These examples show how to define <code>Dirichlet</code>, <code>Neumann</code> and <code>periodic</code> boundary conditions in a square.</p> NeumannDirichletPeriodic <pre><code>    auto list_boundaries_1 = {Boundary(\"left\", 0, \"Neumann\", 0.), Boundary(\"bottom\", 1, \"Neumann\", 0.), Boundary(\"right\", 2, \"Neumann\", 0.), Boundary(\"top\", 3, \"Neumann\", 0.)};\n    auto bcs_1 = BCS(&amp;spatial, list_boundaries_1);\n</code></pre> <p>Non homogeneous Neumann boundary conditions can be defined; however, since they are not part of the <code>SLOTH</code> problems studied so far, their implementation has not yet been developed.          </p> <pre><code>    auto list_boundaries_2 =  {Boundary(\"left\", 0, \"Dirichlet\", 0.), Boundary(\"bottom\", 1, \"Neumann\", 0.), Boundary(\"right\", 2, \"Dirichlet\", 1.), Boundary(\"top\", 3, \"Neumann\", 0.)};\n    auto bcs_2 = BCS(&amp;spatial, list_boundaries_2);\n</code></pre> <pre><code>    auto list_boundaries_3 = {Boundary(\"left\", 0, \"Periodic\"), Boundary(\"bottom\", 1, \"Periodic\"), Boundary(\"right\", 2, \"Periodic\"), Boundary(\"top\", 3, \"Periodic\")};\n    auto bcs_3 = BCS(&amp;spatial, list_boundaries_3);\n</code></pre> <p>Once defined, boundary conditions are associated with variables (see Variables).  The user can define as many boundary conditions as there are variables.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html","title":"Meshing","text":"<p>Definition of a finite element mesh for <code>SLOTH</code> is made with a C++ object of type <code>SpatialDiscretization</code>. <code>SLOTH</code> can either read a <code>GMSH</code> mesh file or use the meshing functionalities provided by <code>MFEM</code>.</p> <p><code>SpatialDiscretization</code> is a template class instantiated with two template parameters: first, the kind of finite element, and second, the spatial dimension.</p> <p>The kind of finite element refers to a C++ class that inherits from the <code>mfem::FiniteElementCollection</code>. This class manages all collections of finite elements provided by <code>MFEM</code>. Currently, the most commonly used finite element collection in <code>SLOTH</code> is <code>mfem::H1_FECollection</code>, which corresponds to arbitrary order H1-conforming continuous finite elements.</p> <p>The dimension is simply an integer that can be 1, 2, or 3.</p> <p>Alias declaration for <code>SpatialDiscretization</code> class template</p> <p><pre><code>using SPA = SpatialDiscretization&lt;mfem::H1_FECollection, 3&gt;;\n</code></pre> This example show how to define a convenient alias for the <code>SpatialDiscretization</code> class template instantiated with <code>mfem::H1_FECollection</code> in dimension 3. </p> <p>Without loss of generality, the alias <code>SPA</code> is used in this page in order to simplify each code snippet.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#gmsh","title":"Build a mesh from <code>GMSH</code> file","text":"<p><code>SLOTH</code> can read a mesh file directly built with <code>GMSH</code>.</p> <p>On the <code>GMSH</code> version used to export meshes</p> <p>For compatibility with the <code>GMSH</code> file reader provided by <code>MFEM</code>, meshes must be exported in ASCII version 2 format.</p> <p>Defining a mesh from <code>GMSH</code> involves creating an object of type <code>SPA</code> with the following parameters:</p> <ol> <li>A string exactly equal to <code>\"GMSH\"</code>,</li> <li>An integer greater than or equal to 1 indicating the order of finite elements,</li> <li>An integer greater than or equal to 0 indicating the level of uniform mesh refinement applied to the initial mesh,</li> <li>A string associated with the name of the <code>GMSH</code> mesh file,</li> <li>A boolean to indicate whether the imported mesh is periodic or not.</li> </ol> <p>Defining a mesh from <code>GMSH</code></p> <p><pre><code>const int order_fe = 1;                                // finite element order\nconst int refinement_level = 0;                        // number of levels of uniform refinement\nconst std::string&amp; filename = \"pellet2Dinclusion.msh\"; // name of the GMSH file\nbool is_periodic = false;                              // flag to indicate if the imported mesh is periodic\n\nSPA spatial(\"GMSH\", order_fe, refinement_level, filename, is_periodic);\n</code></pre> This example demonstrates how to define a mesh from <code>GMSH</code>. It uses first-order finite elements without any refinement, and the mesh contained in the \"pellet2Dinclusion.msh\" file is not periodic.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#mfem","title":"Build a mesh from <code>MFEM</code> meshing functionalities","text":"<p><code>SLOTH</code> can build a mesh using the meshing functionalities provided by <code>MFEM</code>.</p> <p>Here again, defining a mesh involves creating an object of type <code>SPA</code> with the following parameters:</p> <ol> <li> <p>A string specifying the type of mesh from the following list:</p> <ul> <li><code>\"InlineLineWithSegments\"</code> : 1D mesh composed of segments</li> <li><code>\"InlineSquareWithTriangles\"</code> : 2D mesh composed of triangles</li> <li><code>\"InlineSquareWithQuadrangles\"</code> : 2D mesh composed of quadrangles</li> <li><code>\"InlineSquareWithTetraedres\"</code> : 2D mesh composed of tetrahedra</li> <li><code>\"InlineSquareWithHexaedres\"</code> : 2D mesh composed of hexahedra</li> </ul> </li> <li> <p>An integer greater than or equal to 1 indicating the order of finite elements.</p> </li> <li>An integer greater than or equal to 0 indicating the level of uniform mesh refinement applied to the initial mesh.</li> <li>A C++ object of type <code>std::tuple</code> to provide the number of elements and maximum length in each direction.</li> <li>A C++ object of type <code>std::vector&lt;mfem::Vector&gt;</code> to provide translations to apply in each direction, if the final mesh is periodic.</li> </ol> <p>The following examples specify the use of these parameters in 1D, 2D and 3D.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#mfem1D","title":"1D mesh","text":"<p>In this example, the domain corresponds to a line of 1 mm. The mesh is composed of 30 segments. There is no mesh refinement and the finite elements are of order 1.</p> <p>Defining a 1D mesh using the meshing functionalities provided by <code>MFEM</code></p> <pre><code>const std::string&amp; mesh_type = \"InlineLineWithSegments\"; // type of mesh\nconst int order_fe = 1;                                  // finite element order\nconst int refinement_level = 0;                          // number of levels of uniform refinement\nconst std::tuple&lt;int, double&gt;&amp; tuple_of_dimensions = std::make_tuple(30, 1.e-3) ; // Number of elements and maximum length \n\nSPA spatial(mesh_type, order_fe, refinement_level, tuple_of_dimensions );\n</code></pre>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#mfem2D","title":"2D mesh","text":"<p>In these examples, the domain corresponds to a square with a side length of 1 mm. The mesh consists of 30 quadrangles per direction. Triangles can be used by removing <code>\"InlineSquareWithQuadrangles\"</code> by <code>\"InlineSquareWithTriangles\"</code>. There is no mesh refinement, and the finite elements are of order 1.</p> <p>Defining a 2D mesh using the meshing functionalities provided by <code>MFEM</code></p> Without periodicityWith periodicity <pre><code>const std::string&amp; mesh_type = \"InlineSquareWithQuadrangles\"; // type of mesh \nconst int order_fe = 1;                                       // finite element order\nconst int refinement_level = 0;                               // number of levels of uniform refinement\nconst std::tuple&lt;int, int, double, double&gt;&amp; tuple_of_dimensions = std::make_tuple(30, 30, 1.e-3, 1.e-3) ; // Number of elements and maximum length in each direction \n\nSPA spatial(mesh_type, order_fe, refinement_level, tuple_of_dimensions );\n</code></pre> <pre><code>const std::string&amp; mesh_type = \"InlineSquareWithQuadrangles\"; // type of mesh \nconst int order_fe = 1;                                       // finite element order\nconst int refinement_level = 0;                               // number of levels of uniform refinement\nconst std::tuple&lt;int, int, double, double&gt;&amp; tuple_of_dimensions = std::make_tuple(30, 30, 1.e-3, 1.e-3) ; // Number of elements and maximum length in each direction \n\n// Periodicity in x-direction\nmfem::Vector x_translation({1.e-3, 0.0});\n// mfem::Vector y_translation({0.0, 1.e-3});\nstd::vector&lt;mfem::Vector&gt; translations = {x_translation};\n// std::vector&lt;mfem::Vector&gt; translations = {x_translation, y_translation};\n\nSPA spatial(mesh_type, order_fe, refinement_level, tuple_of_dimensions, translations );\n</code></pre> <p>The initial mesh is transformed to a periodic mesh by specifying a translation in the x-direction. See comments in the example to extend periodicity to the top and bottom boundaries.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#mfem3D","title":"3D mesh","text":"<p>In these examples, one considers a cubic domain with a side length of 1 mm. The mesh consists of 30 tetrahedra per direction. Hexahedra can be used by removing <code>\"InlineSquareWithTetraedres\"</code> by <code>\"InlineSquareWithHexaedres\"</code>. There is no mesh refinement, and the finite elements are of order 1.</p> <p>Defining a 3D mesh using the meshing functionalities provided by <code>MFEM</code></p> Without periodicityWith periodicity <pre><code>const std::string&amp; mesh_type = \"InlineSquareWithTetraedres\";  // type of mesh \nconst int order_fe = 1;                                       // finite element order\nconst int refinement_level = 0;                               // number of levels of uniform refinement\nconst std::tuple&lt;int, int, int, double, double, double&gt;&amp; tuple_of_dimensions = std::make_tuple(30, 30, 30, 1.e-3, 1.e-3, 1.e-3) ; // Number of elements and maximum length in each direction \n\nSPA spatial(mesh_type, order_fe, refinement_level, tuple_of_dimensions );\n</code></pre> <pre><code>const std::string&amp; mesh_type = \"InlineSquareWithTetraedres\"; // type of mesh \nconst int order_fe = 1;                                       // finite element order\nconst int refinement_level = 0;                               // number of levels of uniform refinement\nconst std::tuple&lt;int, int, int, double, double, double&gt;&amp; tuple_of_dimensions = std::make_tuple(30, 30, 30, 1.e-3, 1.e-3, 1.e-3) ; // Number of elements and maximum length in each direction \n\n// Periodicity in one direction\nmfem::Vector x_translation({1.e-3, 0.0, 0.0});\nstd::vector&lt;mfem::Vector&gt; translations = {x_translation};\n\nSPA spatial(mesh_type, order_fe, refinement_level, tuple_of_dimensions,  translations);\n</code></pre> <p>A part of the cubic domain is transformed to a periodic domain by specifying a translation in the targeted direction. </p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#gmsh-split-meshes","title":"GMSH Split Meshes","text":"<p>To read directly partitioned meshes, the MFEM miniapps called <code>mesh-explorer</code> must be used.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#use-the-mesh-explorer","title":"Use the Mesh Explorer","text":"<p>Please refer to the documentation at https://mfem.org/meshing-miniapps/#mesh-explorer.</p> <p>Below is a simple example of how to partition the <code>Camembert2D</code> mesh into four files:</p> <pre><code>    spack location -i mfem`/share/mfem/miniapps/meshing/mesh-explorer --mesh camembert2D.msh\n\n    PRESS p // partitioning\n    PRESS 1 // metis\n    PRESS 4 // number of mpi processes\n    PRESS T // Save par\n    PRESS \"camembert2D.\" // mesh name\n    PRESS 6 // digit\n    PRESS q // exit\n</code></pre> <p>This must generate 4 files named: <code>camembert2D.000000</code>, <code>camembert2D.000000</code>, <code>camembert2D.000000</code>, and <code>camembert2D.000003</code>.</p>"},{"location":"Documentation/User/SpatialDiscretization/Meshing/index.html#how-to-read-the-partitionned-files","title":"How to Read the Partitionned Files ?","text":"<p>To read partitionned files, the pattern of the file name, ending explicitly with <code>.</code>, must be specified.</p> <p>Defining a 2D mesh using <code>GMSH</code> Split Meshes</p> <pre><code>    const int order_fe = 1;                                // finite element order\n    const int refinement_level = 0;                        // number of levels of uniform refinement\n    const std::string&amp; pattern = \"camembert2D.\";           // pattern of the file name\n    SPA spatial(\"GMSH\", order_fe, refinement_level, pattern, false);\n</code></pre> <p>Number of processes</p> <p>The number of processes must be equal to the number of files, otherwise reading will fail.</p>"},{"location":"Documentation/User/Variables/index.html","title":"Variables","text":"<p>This page described how to define and manage variables in <code>SLOTH</code>.</p> <p>Definition of variables for <code>SLOTH</code> is made with a C++ object of type <code>Variables</code> that is simply a set of C++ object of type <code>Variable</code>.</p> <p>As for the object <code>SpatialDiscretization</code> (see Meshing), <code>Variable</code> is a template class instantiated with two template parameters: first, the kind of finite element, and second, the spatial dimension.</p> <p>The kind of finite element refers to a C++ class that inherits from the <code>mfem::FiniteElementCollection</code>. This class manages all collections of finite elements provided by <code>MFEM</code>. Currently, the most commonly used finite element collection in <code>SLOTH</code> is <code>mfem::H1_FECollection</code>, which corresponds to arbitrary order H1-conforming continuous finite elements.</p> <p>The dimension is simply an integer that can be 1, 2, or 3.</p> <p>Alias declaration for <code>Variable</code> class template</p> <p><pre><code>using VAR = Variable&lt;mfem::H1_FECollection, 3&gt;;\n</code></pre> This example show how to define a convenient alias for the <code>Variable</code> class template instantiated with <code>mfem::H1_FECollection</code> in dimension 3. This alias is often used in tests in order to simplify the code.</p>"},{"location":"Documentation/User/Variables/index.html#variable","title":"Variable description","text":"<p><code>SLOTH</code> differentiates between primary variables, that are solved directly by the problem (eg. the order parameter for the Allen-Cahn equation, the order parameter and the chemical potential for the Cahn-Hilliard equation), and secondary (or auxiliary) variables, which are derived from another problem to ensure multiphysics coupling (eg. the order parameter in the heat transfer equation, the temperature in the Allen-Cahn equation).  Both kind of variables are defined in the same way.</p>"},{"location":"Documentation/User/Variables/index.html#var_mandatory","title":"Mandatory parameters","text":"<p>The <code>Variable</code> object must be defined by:</p> <ul> <li>the spatial discretisation (see Meshing), </li> <li>a set of boundary conditions(see BoundaryConditions), </li> <li>a name (C++ type <code>std::string</code>), </li> <li>a storage depth level (C++ type <code>int</code>), </li> <li>an initial condition.</li> </ul> <p>The initial condition can be defined by a constant, a C++ object of type <code>std::function</code> or a <code>SLOTH</code> object of type <code>AnalyticalFunctions</code>.  The latter enables to use pre-defined mathematical functions currently used in the studies conducted with <code>SLOTH</code>. If the mathematical expression is not yet available, the users can define it with a C++ object of type <code>std::function</code>.</p> <p>Example of <code>Variable</code>objects with mandatory parameters</p> <p>The following examples assume that the spatial discretisation and the boundary conditions are defined.  In the code snippets, the first is referred to as a <code>spatial</code> object, while the second is referred to as a <code>bcs</code> object. Without loss of generality, the alias <code>VAR</code> is also used.</p> <p>These examples show how to initialize a variable with <code>double</code>, <code>AnalyticalFunctions</code> and <code>std::function</code> types.</p> <code>double</code><code>std::function</code><code>AnalyticalFunctions</code> <p>In this example, the variable is named <code>phi</code>. Its initial value is zero.</p> <pre><code>int level_of_storage= 2;\nstd::string variable_name = \"phi\";\ndouble initial_condition = 0.;\nauto var_1 = VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition);\n</code></pre> <p>In this example, the variable is named <code>T</code>. It is defined by a parabolic profile.</p> <pre><code>int level_of_storage= 2;\nstd::string variable_name = \"T\";\n\nauto initial_condition = std::function&lt;double(const mfem::Vector&amp;, double)&gt;(\n    [](const mfem::Vector&amp; vcoord, double time) {\n        const double Text = 800.;\n        const double radius = 4.e-3;\n        const double puissance = 20.e4;\n        const double conductivity = 2.;\n        const double r2 = radius * radius;\n        double rr = std::transform_reduce(vcoord.begin(), vcoord.begin() + std::min(vcoord.Size(), 2), 0.0, std::plus&lt;&gt;(), [](double x) { return x * x; });\n\n        const auto func = Text + puissance * (r2 - rr) / (4. * M_PI * 2. * r2);\n\n        return func;\n    });\nauto var_1 = VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition);\n</code></pre> <p>In this example, the variable is named <code>phi</code>. It is defined by a 2D hyperbolic tangent profile.</p> <pre><code>int level_of_storage= 2;\nstd::string variable_name = \"phi\";\nconst double center_x = 0.;\nconst double a_x = 1.;\nconst double thickness = 5.e-5;\nconst double radius = 5.e-4;\n\nauto initial_condition = AnalyticalFunctions&lt;2&gt;(AnalyticalFunctionsType::HyperbolicTangent, center_x, a_x, thickness, radius)\n\nauto var_1 = VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition);\n</code></pre> <p><code>SLOTH</code> provides several pre-implemented analytical functions, including the Heaviside function, sinusoidal profiles, hyperbolic tangent, and parabolic profiles. Each of these functions requires a set of parameters detailed in a dedicated page of the user manual.</p>"},{"location":"Documentation/User/Variables/index.html#var_option","title":"Optional parameters","text":"<p>In addition to the mandatory parameters, definition of <code>Variable</code> can be enhanced by an analytical solution with the same type as the initial condition. </p> <p>Definition of variables with an analytical solution</p> <p>The presence of an analytical solution automatically enables the calculation of the  L2L^2L2 error over the domain. </p> <p>The initial condition can also be asscoiated with a set of attributes names that correspond to <code>PhysicalNames</code> defined in the <code>GMSH</code> file mesh.  In this case, the list of attributes (ie the <code>PhysicalNames</code> defined in the <code>GMSH</code> file mesh) must be defined in a C++ container of type <code>std::set&lt;std::string&gt;</code>, just after the initial condition.</p> <p>Example of initialization based on <code>PhysicalNames</code> of a <code>GMSH</code> file mesh</p> <p>Please find the following extract of a <code>GMSH</code> file mesh used to build an inclusion inside a fragment of material:  Mesh of a fragment of material with an inclusion <pre><code>$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$PhysicalNames\n5\n1 1 \"bottom\"\n1 2 \"top\"\n1 3 \"external\"\n2 22 \"pellet\"\n2 23 \"cluster\"\n$EndPhysicalNames\n</code></pre> </p> <p>In the following example, the variable named <code>phi</code> is equal to one within the inclusion associated with the attribute 'cluster' and zero elsewhere.</p> <pre><code>int level_of_storage= 2;\nstd::string variable_name = \"phi\";\ndouble initial_condition = 1.;\nstd::set&lt;std::string&gt; list_of_physical_names = {\"cluster\"};\nauto var_1 = VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition, list_of_physical_names);\n</code></pre> <p> Variable initialization within a fragment of material including an inclusion </p>"},{"location":"Documentation/User/Variables/index.html#additional-information","title":"Additional information","text":"<p>Processing certain physical problems requires additional information to distinguish variables. This information is provided in the form of a list of strings associated with the variables using the public C++ method <code>set_additional_information</code>.</p> <p>Example of variables definition with additional information</p> <p>The following example refers to <code>Calphad</code> problems (see Problems for more details).  The first variable, named <code>Ma</code>, corresponds to a mobility coefficient whereas the second one is associated with a chemical potential named <code>mu_a</code>. </p> <p>For a <code>Calphad</code> problem, managing the variables requires knowing the type of each variable. By convention, the last additional information corresponds to a pre-defined symbol (e.g., 'mu' for chemical potentials and 'mob' for mobilities). </p> <p>The definition of chemical potentials requires the name of the chemical element, whereas for mobilities, both the name of the phase and the name of the chemical element must be specified.</p> <pre><code>    int level_of_storage= 2;\n    std::string variable_name_1 = \"Ma\";\n    double initial_condition_1 = 1.e-15;\n    auto var_1 = VAR(&amp;spatial, bcs, variable_name_1, level_of_storage, initial_condition_1);\n    var_1.set_additional_information(\"SOLUTION\", \"A\", \"mob\");\n\n    std::string variable_name_2 = \"mu_a\";\n    double initial_condition_2 = 1.e5;\n    auto var_2 = VAR(&amp;spatial, bcs, variable_name_2, level_of_storage, initial_condition_2);\n    var_2.set_additional_information(\"A\", \"mu\");\n</code></pre> <p>Conventions used to associate additional information with variables for each kind of <code>SLOTH</code> problem are detailed in Section Problemsof the user manual.</p>"},{"location":"Documentation/User/Variables/index.html#variables","title":"Variables","text":"<p>The C++ class <code>Variables</code> allows to define a collection of <code>Variable</code> objects.  As for the object <code>Variable</code>, <code>Variables</code> is a template class instantiated with two template parameters: first, the kind of finite element, and second, the spatial dimension.</p> <p>Each <code>SLOTH</code> problem (see Problems for more details) requires a <code>Variables</code> object as input argumet.</p> <p>Example of <code>Variables</code> definition</p> <pre><code>    std::string variable_name_1 = \"mu_a\";\n    double initial_condition_1 = 1.e5;\n    auto var_1 = VAR(&amp;spatial, bcs, variable_name_1, level_of_storage, initial_condition_1);\n    var_1.set_additional_information(\"A\", \"mu\");\n\n    std::string variable_name_2 = \"mu_a\";\n    double initial_condition_2 = 2.e5;\n    auto var_2 = VAR(&amp;spatial, bcs, variable_name_2, level_of_storage, initial_condition_2);\n    var_2.set_additional_information(\"A\", \"mu\");\n\n    auto mu_var = VARS(var_1, var_2);\n</code></pre> <p>This example shows the definition of two variables that correspond to chemical potentials. These variables are gathered within a <code>Variables</code> object that can be used as primary variables for a <code>CALPHAD</code> problem and as auxiliary variables for <code>ThermalDiffusion</code> problems.</p>"},{"location":"References/index.html","title":"References","text":"<p>A reference paper for <code>SLOTH</code> is in preparation. </p>"},{"location":"Started/index.html","title":"A Step-By-Step Guide","text":"<p>This page provides users with comprehensive information on installing and using SLOTH, making it easier to develop custom applications. </p> <ul> <li>Installation guide </li> <li>Examples</li> <li>Code quality</li> <li>How to build an application</li> </ul> <p>Before following these instructions, users are required to clone the code of SLOTH, which is available for download from Github. </p> <pre><code>git clone https://github.com/Collab4Sloth/SLOTH.git \n</code></pre> <p>SLOTH project</p> <p>Scanning this QR code will direct users to other associated repositories: </p> DocumentationGalleryStudies <p>This repository is dedicted to the documentation of the project including the user manual and the physical description of models implemented in SLOTH.</p> <pre><code>git clone https://github.com/Collab4Sloth/Documentation.git\n</code></pre> <p>This repository is the Hall of Fame of simulations performed with SLOTH.</p> <pre><code>git clone https://github.com/Collab4Sloth/Gallery.git\n</code></pre> <p>Please note that this repository is still under construction. It will contain all the information from public studies conducted with SLOTH. </p> <pre><code>git clone https://github.com/Collab4Sloth/Studies.git\n</code></pre>"},{"location":"Started/Examples/index.html","title":"Examples","text":"<p>This page describes the tests that are relevant for performing multiphysics simulations. </p> <p>These tests are naturally grouped into the following categories:</p> <ul> <li>Cahn-Hilliard </li> <li>Allen-Cahn</li> <li>Mass Diffusion</li> <li>Thermal Diffusion</li> <li>CALPHAD</li> </ul> <p>They are continuously run during the <code>SLOTH</code> continuous integration process to detect code regressions early while maintaining high code coverage.</p>"},{"location":"Started/Examples/AllenCahn/index.html","title":"Allen-Cahn  (cooming soon)","text":"<p>Verification of the Allen-Cahn equations is made with the following tests:</p> <ul> <li>Analytical steady solution (see Example 1)</li> </ul> <p>Description of tests</p> <p>The list of tests is not exhaustive. Description of all tests will be completed over time.</p>"},{"location":"Started/Examples/AllenCahn/example1/index.html","title":"Example 1: steady-state solution of the Allen-Cahn equations","text":""},{"location":"Started/Examples/AllenCahn/example1/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: convergence_output_ref.csv</li> </ul>"},{"location":"Started/Examples/AllenCahn/example1/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test consists of finding the steady-state solution of the Allen-Cahn equations. A transient simulation is performed to reach this steady-state, and a convergence analysis is carried out to ensure the consistency of the results.</p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,1]\u00d7[0,1][0,1]\\times[0,1][0,1]\u00d7[0,1]</p> <p>\u2202\u03d5\u2202t=\u2212M(F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5)\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;=-M (F'(\\phi) - \\lambda \\Delta \\phi) \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u200b=\u2212M(F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5)\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03c9\u03d52(1\u2212\u03d5)2  \\begin{align}  F(\\phi)&amp;=\\omega\\phi^2(1-\\phi)^2 \\end{align}  F(\u03d5)\u200b=\u03c9\u03d52(1\u2212\u03d5)2\u200b\u200b</p>"},{"location":"Started/Examples/AllenCahn/example1/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition is given by:</p> <p>\u03d5=12+12tanh\u2061(x\u22120.55\u22c510\u22123).      \\phi =  \\dfrac{1}{2} + \\dfrac{1}{2} \\tanh\\left(\\dfrac{x-0.5}{5\\cdot 10^{-3}}\\right).  \u03d5=21\u200b+21\u200btanh(5\u22c510\u22123x\u22120.5\u200b).</p>"},{"location":"Started/Examples/AllenCahn/example1/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, all parameters are equal to one. </p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 1.01.01.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 32\u03c3\u03f5\\dfrac{3}{2}{\\sigma}{\\epsilon}23\u200b\u03c3\u03f5 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 12\u03c3\u03f512\\dfrac{\\sigma}{\\epsilon}12\u03f5\u03c3\u200b <code>sigma</code> surface tension \u03c3\\sigma\u03c3 1.01.01.0 <code>epsilon</code> thickness of interface \u03f5\\epsilon\u03f5 0.10.10.1"},{"location":"Started/Examples/AllenCahn/example1/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann and Dirichlet boundary conditions are prescribed on boundary of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9top\u2229\u2202\u03a9bottom\u03d5=1\u00a0on\u00a0\u2202\u03a9right\u03d5=0\u00a0on\u00a0\u2202\u03a9left  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega_{top}\\cap\\partial\\Omega_{bottom}  \\\\[6pt]  \\phi&amp;=1 \\text{ on }\\partial\\Omega_{right} \\\\[6pt]  \\phi&amp;=0 \\text{ on }\\partial\\Omega_{left} \\end{align} n\u22c5\u03bb\u2207\u03d5\u03d5\u03d5\u200b=0\u00a0on\u00a0\u2202\u03a9top\u200b\u2229\u2202\u03a9bottom\u200b=1\u00a0on\u00a0\u2202\u03a9right\u200b=0\u00a0on\u00a0\u2202\u03a9left\u200b\u200b\u200b</p>"},{"location":"Started/Examples/AllenCahn/example1/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,1]t\\in[0,1]t\u2208[0,1] with a time-step \u03b4t=10\u22123\\delta t=10^{-3}\u03b4t=10\u22123. The calculation stops when convergence criteria are reached.</li> </ul> <p>\u2225\u03d5(t+\u03b4t)\u2212\u03d5(t)\u2225&lt;\u03f5\u03d5  \\|{\\phi(t+\\delta t)-\\phi(t)}\\|&lt;\\epsilon_\\phi   \u2225\u03d5(t+\u03b4t)\u2212\u03d5(t)\u2225&lt;\u03f5\u03d5\u200b</p> <p>where  \u03f5\u03d5=10\u221212\\epsilon_\\phi=10^{-12}\u03f5\u03d5\u200b=10\u221212. </p> <ul> <li>Spatial discretization for convergence analysis: uniform grid with N=30,60,90,120N={30, 60, 90, 120}N=30,60,90,120 nodes in each spatial direction, with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements</li> <li>Newton solver: relative tolerance 10\u22121210^{-12}10\u221212, absolute tolerance 10\u22121210^{-12}10\u221212</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/AllenCahn/example1/index.html#results","title":"Results","text":"<p>The steady state solution is given by:</p> <p>\u03d5=12+12tanh\u2061(x\u22120.5\u03f5).      \\phi =  \\dfrac{1}{2} + \\dfrac{1}{2} \\tanh\\left(\\dfrac{x-0.5}{\\epsilon}\\right).  \u03d5=21\u200b+21\u200btanh(\u03f5x\u22120.5\u200b).</p> <p>Figures 1 shows the results of convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b.</p> Figure 1: convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements"},{"location":"Started/Examples/CahnHilliard/index.html","title":"Cahn-Hilliard","text":"<p>Verification of the Cahn-Hilliard equations is made with the following tests:</p> <ul> <li>Coalescence of two kissing bubbles (see Example 1)</li> <li>Square bubble (see Example 2)</li> <li>Spinodal decomposition (see Example 3)</li> <li>Manufactured Cahn-Hilliard Solution (see Example 4)</li> <li>Analytical steady solution (see Example 5)</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example1/index.html","title":"Example 1: coalescence of two bubbles","text":""},{"location":"Started/Examples/CahnHilliard/example1/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: time_specialized.csv</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example1/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test corresponds to a 2D simulation of coalescence of two kissing bubbles. </p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,2\u03c0]\u00d7[0,2\u03c0][0,2\\pi]\\times[0,2\\pi][0,2\u03c0]\u00d7[0,2\u03c0]</p> <p>\u2202\u03d5\u2202t=\u0394\u03bc\u00a0in\u00a0\u03a9\u03bc=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= \\Delta \\mu \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= F'(\\phi) - \\lambda \\Delta \\phi \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=\u0394\u03bc\u00a0in\u00a0\u03a9=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03d544\u2212\u03d522  \\begin{align}  F(\\phi)&amp;=\\frac{\\phi^4}{4} - \\frac{\\phi^2}{2} \\end{align}  F(\u03d5)\u200b=4\u03d54\u200b\u22122\u03d52\u200b\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example1/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition consists of two bubbles:</p> <p>\u03d5={1,if\u00a0(x\u2212\u03c0+1)2+(y\u2212\u03c0)2&lt;1 or (x\u2212\u03c0\u22121)2+(y\u2212\u03c0)2&lt;1\u22121,otherwise      \\phi =     \\begin{cases}          1, &amp; \\text{if } (x - \\pi + 1)^2 + (y - \\pi)^2 &lt; 1 \\;\\; \\text{or} \\;\\; (x - \\pi - 1)^2 + (y - \\pi)^2 &lt; 1      \\\\     -1, &amp; \\text{otherwise}      \\end{cases}  \u03d5={1,\u22121,\u200bif\u00a0(x\u2212\u03c0+1)2+(y\u2212\u03c0)2&lt;1or(x\u2212\u03c0\u22121)2+(y\u2212\u03c0)2&lt;1otherwise\u200b</p> Figure 1 : two kissing bubbles at initial state"},{"location":"Started/Examples/CahnHilliard/example1/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, all parameters are equal to one except the energy gradient coefficient. </p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 1.01.01.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 4.10\u221244.10^{-4}4.10\u22124 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 1.01.01.0"},{"location":"Started/Examples/CahnHilliard/example1/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on the boundary of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9n\u22c5\u03bb\u2207\u03bc=0\u00a0on\u00a0\u2202\u03a9  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega  \\\\[6pt]  {\\bf{n}} \\cdot{} \\lambda \\nabla \\mu&amp;=0 \\text{ on }\\partial\\Omega \\end{align} n\u22c5\u03bb\u2207\u03d5n\u22c5\u03bb\u2207\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9=0\u00a0on\u00a0\u2202\u03a9\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example1/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,0.5]t\\in[0,0.5]t\u2208[0,0.5] (it could be extended further) with a time-step \u03b4t=0.05\\delta t=0.05\u03b4t=0.05</li> <li>Spatial discretization: uniform grid with N=128N=128N=128 nodes in each spatial direction</li> <li>Newton solver: relative tolerance 10\u22121010^{-10}10\u221210, absolute tolerance 10\u22121410^{-14}10\u221214</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example1/index.html#results","title":"Results","text":"<p>The average value of \u03d5\\phi\u03d5 is an available ouput of the simulation (see the file <code>time_specialized.csv</code>). It is defined by:</p> <p>1\u2223\u03a9\u2223\u222b\u03a9\u03d5dv  \\dfrac{1}{|\\Omega|}\\displaystyle\\int_{\\Omega} \\phi dv   \u2223\u03a9\u22231\u200b\u222b\u03a9\u200b\u03d5dv</p> <p>For this test, the computed average value should remain constant over time.</p> <p>The figure 2 shows the coalescence of the two bubbles, with a final simulation time set to 505050.</p> Figure 2 : coalescence two kissing bubbles"},{"location":"Started/Examples/CahnHilliard/example2/index.html","title":"Example 2: from a square to a bubble","text":""},{"location":"Started/Examples/CahnHilliard/example2/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: time_specialized.csv</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example2/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test corresponds to a 2D simulation of a square evolving to a bubble. </p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,2\u03c0]\u00d7[0,2\u03c0][0,2\\pi]\\times[0,2\\pi][0,2\u03c0]\u00d7[0,2\u03c0]</p> <p>\u2202\u03d5\u2202t=\u0394\u03bc\u00a0in\u00a0\u03a9\u03bc=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= \\Delta \\mu \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= F'(\\phi) - \\lambda\\Delta \\phi \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=\u0394\u03bc\u00a0in\u00a0\u03a9=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03d544\u2212\u03d522  \\begin{align}  F(\\phi)&amp;=\\frac{\\phi^4}{4} - \\frac{\\phi^2}{2} \\end{align}  F(\u03d5)\u200b=4\u03d54\u200b\u22122\u03d52\u200b\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example2/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition consists of square:</p> <p>\u03d5={1,if\u00a0(x\u2212\u03c0+1)\u22641 or (y\u2212\u03c0)\u22641\u22121,otherwise      \\phi =     \\begin{cases}          1, &amp; \\text{if } (x - \\pi + 1) \\leq 1 \\;\\; \\text{or} \\;\\;  (y - \\pi) \\leq 1      \\\\     -1, &amp; \\text{otherwise}      \\end{cases}  \u03d5={1,\u22121,\u200bif\u00a0(x\u2212\u03c0+1)\u22641or(y\u2212\u03c0)\u22641otherwise\u200b</p> Figure 1 : square bubble at initial state"},{"location":"Started/Examples/CahnHilliard/example2/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, all parameters are equal to one except the energy gradient coefficient. </p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 1.01.01.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 4.10\u221244.10^{-4}4.10\u22124 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 1.01.01.0"},{"location":"Started/Examples/CahnHilliard/example2/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on the boundary of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9n\u22c5\u03bb\u2207\u03bc=0\u00a0on\u00a0\u2202\u03a9  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega  \\\\[6pt]  {\\bf{n}} \\cdot{} \\lambda \\nabla \\mu&amp;=0 \\text{ on }\\partial\\Omega \\end{align} n\u22c5\u03bb\u2207\u03d5n\u22c5\u03bb\u2207\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9=0\u00a0on\u00a0\u2202\u03a9\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example2/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,1]t\\in[0,1]t\u2208[0,1] (it could be extended further) with a time-step \u03b4t=0.1\\delta t=0.1\u03b4t=0.1</li> <li>Spatial discretization: uniform grid with N=128N=128N=128 nodes in each spatial direction</li> <li>Newton solver: relative tolerance 10\u2212810^{-8}10\u22128, absolute tolerance 10\u22121410^{-14}10\u221214</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example2/index.html#results","title":"Results","text":"<p>The average value of \u03d5\\phi\u03d5 is an available ouput of the simulation (see the file <code>time_specialized.csv</code>). It is defined by:</p> <p>1\u2223\u03a9\u2223\u222b\u03a9\u03d5dv  \\dfrac{1}{|\\Omega|}\\displaystyle\\int_{\\Omega} \\phi dv   \u2223\u03a9\u22231\u200b\u222b\u03a9\u200b\u03d5dv</p> <p>For this test, the computed average value should remain constant over time.</p> <p>The figure 2 shows the evolution of a square to a bubble, with a final simulation time set to 101010.</p> Figure 2 : evolution of a square to a bubble"},{"location":"Started/Examples/CahnHilliard/example3/index.html","title":"Example 3: spinodal decomposition","text":""},{"location":"Started/Examples/CahnHilliard/example3/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: time_specialized.csv</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example3/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test corresponds to the 2D simulation of spinodal decomposition proposed on PFhub</p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,200]\u00d7[0,200][0,200]\\times[0,200][0,200]\u00d7[0,200]</p> <p>\u2202\u03d5\u2202t=M\u0394\u03bc\u00a0in\u00a0\u03a9\u03bc=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= M\\Delta \\mu \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= F'(\\phi) - \\lambda \\Delta \\phi \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=M\u0394\u03bc\u00a0in\u00a0\u03a9=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03c9(\u03d5\u22120.3)2(0.7\u2212\u03d5)2.  \\begin{align}  F(\\phi)&amp;=\\omega(\\phi - 0.3)^2 (0.7 - \\phi)^2. \\end{align}  F(\u03d5)\u200b=\u03c9(\u03d5\u22120.3)2(0.7\u2212\u03d5)2.\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example3/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition is defined by:</p> <p>\u03d5=0.5+0.01[cos\u2061(0.105x)cos\u2061(0.11y)+(cos\u2061(0.13x)cos\u2061(0.087y))2+cos\u2061(0.025x\u22120.15y)cos\u2061(0.07x\u22120.02y)]      \\phi = 0.5 + 0.01  \\left[\\cos(0.105x)\\cos(0.11y) +(\\cos(0.13x)\\cos(0.087y))^2+ \\cos(0.025x - 0.15y)\\cos(0.07x - 0.02y)\\right]  \u03d5=0.5+0.01[cos(0.105x)cos(0.11y)+(cos(0.13x)cos(0.087y))2+cos(0.025x\u22120.15y)cos(0.07x\u22120.02y)]</p> Figure 1: initial state"},{"location":"Started/Examples/CahnHilliard/example3/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, the following parameters are considered:</p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 5.05.05.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 2.02.02.0 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 5.05.05.0"},{"location":"Started/Examples/CahnHilliard/example3/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on the boundary of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9n\u22c5\u03bb\u2207\u03bc=0\u00a0on\u00a0\u2202\u03a9  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega  \\\\[6pt]  {\\bf{n}} \\cdot{} \\lambda \\nabla \\mu&amp;=0 \\text{ on }\\partial\\Omega \\end{align} n\u22c5\u03bb\u2207\u03d5n\u22c5\u03bb\u2207\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9=0\u00a0on\u00a0\u2202\u03a9\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example3/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,10]t\\in[0,10]t\u2208[0,10] (it could be extended further) with a time-step \u03b4t=1\\delta t=1\u03b4t=1</li> <li>Spatial discretization: uniform grid with N=100N=100N=100 nodes in each spatial direction</li> <li>Newton solver: relative tolerance 10\u22121210^{-12}10\u221212, absolute tolerance 10\u22121210^{-12}10\u221212</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example3/index.html#results","title":"Results","text":"<p>The average value of \u03d5\\phi\u03d5 is an available ouput of the simulation (see the file <code>time_specialized.csv</code>). It is defined by:</p> <p>1\u2223\u03a9\u2223\u222b\u03a9\u03d5dv  \\dfrac{1}{|\\Omega|}\\displaystyle\\int_{\\Omega} \\phi dv   \u2223\u03a9\u22231\u200b\u222b\u03a9\u200b\u03d5dv</p> <p>For this test, the computed average value should remain constant over time.</p> <p>The figure 2 shows the spinodal decomposition, with a final simulation time set to 100001000010000. </p> Figure 2 : spinodal decomposition      <p>Figure 3 shows the time evolution of the normalized free-energy density, with snapshots taken at 100100100, 100010001000 and 100001000010000 s.</p> Figure 3 : time evolution of the normalized density of free energy"},{"location":"Started/Examples/CahnHilliard/example4/index.html","title":"Example 4: steady-state solution of the Cahn\u2013Hilliard equations","text":""},{"location":"Started/Examples/CahnHilliard/example4/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: convergence_output_ref.csv</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example4/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test consists of finding the steady-state solution of the Cahn\u2013Hilliard equations. A transient simulation is performed to reach this steady-state, and a convergence analysis is carried out to ensure the consistency of the results.</p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,1]\u00d7[0,1][0,1]\\times[0,1][0,1]\u00d7[0,1]</p> <p>\u2202\u03d5\u2202t=M\u0394\u03bc\u00a0in\u00a0\u03a9\u03bc=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;=M \\Delta \\mu \\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= F'(\\phi) - \\lambda \\Delta \\phi \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=M\u0394\u03bc\u00a0in\u00a0\u03a9=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03c9\u03d52(1\u2212\u03d5)2  \\begin{align}  F(\\phi)&amp;=\\omega\\phi^2(1-\\phi)^2 \\end{align}  F(\u03d5)\u200b=\u03c9\u03d52(1\u2212\u03d5)2\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example4/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition is given by:</p> <p>\u03d5=12+12tanh\u2061(x\u22120.55\u22c510\u22123).      \\phi =  \\dfrac{1}{2} + \\dfrac{1}{2} \\tanh\\left(\\dfrac{x-0.5}{5\\cdot 10^{-3}}\\right).  \u03d5=21\u200b+21\u200btanh(5\u22c510\u22123x\u22120.5\u200b).</p>"},{"location":"Started/Examples/CahnHilliard/example4/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, all parameters are equal to one. </p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 1.01.01.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 32\u03c3\u03f5\\dfrac{3}{2}{\\sigma}{\\epsilon}23\u200b\u03c3\u03f5 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 12\u03c3\u03f512\\dfrac{\\sigma}{\\epsilon}12\u03f5\u03c3\u200b <code>sigma</code> surface tension \u03c3\\sigma\u03c3 1.01.01.0 <code>epsilon</code> thickness of interface \u03f5\\epsilon\u03f5 0.10.10.1"},{"location":"Started/Examples/CahnHilliard/example4/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on boundary of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9n\u22c5\u03bb\u2207\u03bc=0\u00a0on\u00a0\u2202\u03a9  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega  \\\\[6pt]  {\\bf{n}} \\cdot{} \\lambda \\nabla \\mu&amp;=0 \\text{ on }\\partial\\Omega \\end{align} n\u22c5\u03bb\u2207\u03d5n\u22c5\u03bb\u2207\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9=0\u00a0on\u00a0\u2202\u03a9\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example4/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,1]t\\in[0,1]t\u2208[0,1] with a time-step \u03b4t=10\u22123\\delta t=10^{-3}\u03b4t=10\u22123. The calculation stops when convergence criteria are reached.</li> </ul> <p>\u2225\u03d5(t+\u03b4t)\u2212\u03d5(t)\u2225&lt;\u03f5\u03d5\u2225\u03bc(t+\u03b4t)\u2212\u03bc(t)\u2225&lt;\u03f5\u03bc  \\|{\\phi(t+\\delta t)-\\phi(t)}\\|&lt;\\epsilon_\\phi  \\\\[6pt]  \\|{\\mu(t+\\delta t)-\\mu(t)}\\|&lt;\\epsilon_\\mu  \u2225\u03d5(t+\u03b4t)\u2212\u03d5(t)\u2225&lt;\u03f5\u03d5\u200b\u2225\u03bc(t+\u03b4t)\u2212\u03bc(t)\u2225&lt;\u03f5\u03bc\u200b</p> <p>where  \u03f5\u03d5=10\u221212\\epsilon_\\phi=10^{-12}\u03f5\u03d5\u200b=10\u221212 and \u03f5\u03bc=10\u22127\\epsilon_\\mu=10^{-7}\u03f5\u03bc\u200b=10\u22127. </p> <ul> <li>Spatial discretization for convergence analysis: uniform grid with N=30,60,90,120N={30, 60, 90, 120}N=30,60,90,120 nodes in each spatial direction, with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements</li> <li>Newton solver: relative tolerance 10\u22121210^{-12}10\u221212, absolute tolerance 10\u22121210^{-12}10\u221212</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example4/index.html#results","title":"Results","text":"<p>The steady state solution is given by:</p> <p>\u03d5=12+12tanh\u2061(x\u22120.5\u03f5).      \\phi =  \\dfrac{1}{2} + \\dfrac{1}{2} \\tanh\\left(\\dfrac{x-0.5}{\\epsilon}\\right).  \u03d5=21\u200b+21\u200btanh(\u03f5x\u22120.5\u200b).</p> <p>Figures 1 shows the results of convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b.</p> Figure 1: convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements"},{"location":"Started/Examples/CahnHilliard/example5/index.html","title":"Example 5: MMS benchmark","text":""},{"location":"Started/Examples/CahnHilliard/example5/index.html#files","title":"Files","text":"<ul> <li>Comprehensive test file: main.cpp</li> <li>Reference results for comparison: convergence_output_ref.csv</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example5/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This test is taken from Zhang &amp; al.<sup>1</sup>.  It consists of spatial convergence analysis based on a manufactured solution benchmark.</p> <p>The domain \u03a9\\Omega\u03a9 is a square [0,1]\u00d7[0,1][0,1]\\times[0,1][0,1]\u00d7[0,1]</p> <p>\u2202\u03d5\u2202t=\u0394\u03bc+S(x,y,t)\u00a0in\u00a0\u03a9\u03bc=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial \\phi}{\\partial t}&amp;= \\Delta \\mu +S(x,y,t)\\text{ in }\\Omega  \\\\[6pt]     \\mu &amp;= F'(\\phi) - \\lambda \\Delta \\phi \\text{ in }\\Omega  \\end{align}  \u2202t\u2202\u03d5\u200b\u03bc\u200b=\u0394\u03bc+S(x,y,t)\u00a0in\u00a0\u03a9=F\u2032(\u03d5)\u2212\u03bb\u0394\u03d5\u00a0in\u00a0\u03a9\u200b\u200b</p> <p>where \u03d5\\phi\u03d5 is the phase indicator, \u03bc\\mu\u03bc the generalized chemical potential and F\u2032F'F\u2032 the derivative against \u03d5\\phi\u03d5 of the potential FFF defined by:</p> <p>F(\u03d5)=\u03d544\u2212\u03d522  \\begin{align}  F(\\phi)&amp;=\\frac{\\phi^4}{4} - \\frac{\\phi^2}{2} \\end{align}  F(\u03d5)\u200b=4\u03d54\u200b\u22122\u03d52\u200b\u200b\u200b</p> <p>In equation (1), S(x,y,t)S(x,y,t)S(x,y,t) is the source term allowing the exact solution:</p> <p>\u03d5=(t+1)sin\u2061(\u03b1\u03c0x)   \\phi = (t+1) \\sin(\\alpha \\pi x)  \u03d5=(t+1)sin(\u03b1\u03c0x)</p>"},{"location":"Started/Examples/CahnHilliard/example5/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition is given by:</p> <p><p>\u03d5=sin\u2061(\u03b1\u03c0x)      \\phi =  \\sin(\\alpha \\pi x)  \u03d5=sin(\u03b1\u03c0x)</p> For this test, \u03b1\\alpha\u03b1 is set to 111.</p>"},{"location":"Started/Examples/CahnHilliard/example5/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, all parameters are equal to one. </p> Name Description Symbol Value <code>mob</code> mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 1.01.01.0 <code>lambda</code> energy gradient coefficient \u03bb\\lambda\u03bb 1.01.01.0 <code>omega</code> depth of the double-well potential \u03c9\\omega\u03c9 1.01.01.0"},{"location":"Started/Examples/CahnHilliard/example5/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on the top and bottom of the domain:</p> <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u2202\u03a9top\u222a\u2202\u03a9bottomn\u22c5\u03bb\u2207\u03bc=0\u00a0on\u00a0\u2202\u03a9top\u222a\u2202\u03a9bottom  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi&amp;=0 \\text{ on }\\partial\\Omega_{top}\\cup\\partial\\Omega_{bottom}  \\\\[6pt]  {\\bf{n}} \\cdot{} \\lambda \\nabla \\mu&amp;=0 \\text{ on }\\partial\\Omega_{top}\\cup\\partial\\Omega_{bottom} \\end{align} n\u22c5\u03bb\u2207\u03d5n\u22c5\u03bb\u2207\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9top\u200b\u222a\u2202\u03a9bottom\u200b=0\u00a0on\u00a0\u2202\u03a9top\u200b\u222a\u2202\u03a9bottom\u200b\u200b\u200b</p> <p>Dirichlet boundary conditions are prescribed on the right and left of the domain:</p> <p>\u03d5=0\u00a0on\u00a0\u2202\u03a9left\u222a\u2202\u03a9right\u03bc=0\u00a0on\u00a0\u2202\u03a9left\u222a\u2202\u03a9right  \\begin{align}  \\phi&amp;=0 \\text{ on }\\partial\\Omega_{left}\\cup\\partial\\Omega_{right}  \\\\[6pt]  \\mu&amp;=0 \\text{ on }\\partial\\Omega_{left}\\cup\\partial\\Omega_{right} \\end{align} \u03d5\u03bc\u200b=0\u00a0on\u00a0\u2202\u03a9left\u200b\u222a\u2202\u03a9right\u200b=0\u00a0on\u00a0\u2202\u03a9left\u200b\u222a\u2202\u03a9right\u200b\u200b\u200b</p>"},{"location":"Started/Examples/CahnHilliard/example5/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,1]t\\in[0,1]t\u2208[0,1] with a time-step \u03b4t=1\\delta t=1\u03b4t=1. </li> <li>Spatial discretization for convergence analysis: uniform grid with N=160,80,40,20N={160, 80, 40, 20}N=160,80,40,20 nodes in each spatial direction, with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements</li> <li>Newton solver: relative tolerance 10\u2212810^{-8}10\u22128, absolute tolerance 10\u22121210^{-12}10\u221212</li> <li>Iterative solver: HYPRE_GMRES </li> <li>Preconditioner: HYPRE_ILU</li> </ul>"},{"location":"Started/Examples/CahnHilliard/example5/index.html#results","title":"Results","text":"<p>Figures 1 shows the results of convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b.</p> Figure 1: convergence analysis with Q1\\mathcal{Q}_1Q1\u200b and Q2\\mathcal{Q}_2Q2\u200b finite elements      <ol> <li> <p>Liangzhe Zhang, Michael R Tonks, Derek Gaston, John W Peterson, David Andrs, Paul C Millett, and Bulent S Biner. A quantitative comparison between c0 and c1 elements for solving the cahn\u2013hilliard equation. Journal of Computational Physics, 236:74\u201380, 2013.\u00a0\u21a9</p> </li> </ol>"},{"location":"Started/Examples/Calphad/index.html","title":"Calphad (coming soon)","text":"<p>Description of tests</p> <p>Description of all tests will be completed over time.</p>"},{"location":"Started/Examples/MassDiffusion/index.html","title":"Mass Diffusion (coming soon)","text":"<p>Verification of the diffusion equations is made with the following tests:</p> <ul> <li>Nonlinear diffusion in a star (see Example 1)</li> </ul> <p>Description of tests</p> <p>The list of tests is not exhaustive. Description of all tests will be completed over time.</p>"},{"location":"Started/Examples/MassDiffusion/example1/index.html","title":"Example 1: nonlinear diffusion in a star","text":""},{"location":"Started/Examples/MassDiffusion/example1/index.html#files","title":"Files","text":"<ul> <li> <p>Comprehensive test files: </p> <ul> <li>explicit diffusion coefficient : main.cpp</li> <li>implicit diffusion coefficient : main.cpp</li> </ul> </li> <li> <p>Reference results for comparison: </p> <ul> <li>explicit diffusion coefficient :time_specialized.csv</li> <li>implicit diffusion coefficient :time_specialized.csv</li> </ul> </li> </ul>"},{"location":"Started/Examples/MassDiffusion/example1/index.html#statement-of-the-problem","title":"Statement of the problem","text":"<p>This example code is based on the \"Example 16: Time Dependent Heat Conduction\",  on MFEM's website. It solves a diffusion equation in a 2D star \u03a9\\Omega\u03a9 (GMSH mesh coming from MFEM examples).</p> <p><p>\u2202c\u2202t=[\u2207\u22c5(\u03ba+\u03b1c)\u2207c]\u00a0in\u00a0\u03a9  \\begin{align} \\frac{\\partial c}{\\partial t}&amp;=[\\nabla \\cdot{} \\displaystyle(\\kappa+\\alpha c) \\nabla c ]\\text{ in }\\Omega \\end{align}  \u2202t\u2202c\u200b\u200b=[\u2207\u22c5(\u03ba+\u03b1c)\u2207c]\u00a0in\u00a0\u03a9\u200b\u200b</p> where the concentration ccc in the diffusion coefficient can be evaluated at the previous time step, as done in the MFEM example, or at the current time step to form a fully nonlinear system.</p>"},{"location":"Started/Examples/MassDiffusion/example1/index.html#initial-condition","title":"Initial condition","text":"<p>The initial condition is set to 222 inside a circle of radius 0.50.50.5, 111 outside.</p>"},{"location":"Started/Examples/MassDiffusion/example1/index.html#parameters-used-for-the-test","title":"Parameters used for the test","text":"<p>For this test, the following parameters are considered:</p> Parameter Symbol Value Primary coefficient \u03ba\\kappa\u03ba 0.50.50.5 Secondary coefficient \u03b1\\alpha\u03b1 10\u2212210^{-2}10\u22122"},{"location":"Started/Examples/MassDiffusion/example1/index.html#boundary-conditions","title":"Boundary conditions","text":"<p>Neumann boundary conditions are prescribed on the boundary of the domain:</p> <p>n\u22c5\u03bb\u2207c=0\u00a0on\u00a0\u2202\u03a9  \\begin{align}  {\\bf{n}} \\cdot{} \\lambda \\nabla c&amp;=0 \\text{ on }\\partial\\Omega \\end{align} n\u22c5\u03bb\u2207c\u200b=0\u00a0on\u00a0\u2202\u03a9\u200b\u200b</p>"},{"location":"Started/Examples/MassDiffusion/example1/index.html#numerical-scheme","title":"Numerical scheme","text":"<ul> <li>Time integration: Euler Implicit over the interval t\u2208[0,0.5]t\\in[0,0.5]t\u2208[0,0.5], \u03b4t=0.01\\delta t=0.01\u03b4t=0.01</li> <li>Spatial discretization: built from GMSH + quadratic FE + 222 uniform levels of refinement (it could be extended further)</li> </ul>"},{"location":"Started/Examples/MassDiffusion/example1/index.html#results","title":"Results","text":"<p>The figure 1 shows the nonlinear diffusion inside the star.</p> Figure 1: nonlinear diffusion in a star obtained with 555 level of refinement."},{"location":"Started/Examples/ThermalDiffusion/index.html","title":"Thermal Diffusion (coming soon)","text":"<p>Description of tests</p> <p>Description of all tests will be completed over time.</p>"},{"location":"Started/HowTo/index.html","title":"Index","text":""},{"location":"Started/HowTo/index.html#howto","title":"HowTo","text":"<p>This page comprises two sections:</p> <ul> <li>The first section provides a description of the basic features of a SLOTH test as implemented in a very simple simulation;</li> <li>The second section offers tutorials that provide comprehensive explanations of the more advanced features and how to use them to run more complex simulations.</li> </ul>"},{"location":"Started/HowTo/Simple/index.html","title":"Basic features","text":"<p>This page provides a description of the basic features of a <code>SLOTH</code> test as implemented in a very simple simulation.  This description is based on a very simple example, but the data structure shown is common to all <code>SLOTH</code> simulations.</p> <p>On this page, the users can find the most important parts of a <code>SLOTH</code> input dataset and go to the pages of the User Manual that give all the options and the instructions for using them.</p> <p>Statement of the problem</p> <p>The current description is based on a simple example code that solves the Allen-Cahn equation in a 1D domain \u03a9=[0,R]\\Omega=[0,R]\u03a9=[0,R] with R=10\u22123R=10^{-3}R=10\u22123. </p> Governing equationBoundary conditionsParametersNumerical scheme <p>Let us consider the following set of governing equations:</p> <p><p>\u2202\u03d5\u2202t=M\u03d5[\u2207\u22c5\u03bb\u2207\u03d5\u2212\u03c9W\u2032(\u03d5)]\u00a0in\u00a0\u03a9 \\frac{\\partial \\phi}{\\partial t}=M_\\phi[\\nabla \\cdot{} \\lambda \\nabla \\phi -\\omega W'(\\phi)]\\text{ in }\\Omega  \u2202t\u2202\u03d5\u200b=M\u03d5\u200b[\u2207\u22c5\u03bb\u2207\u03d5\u2212\u03c9W\u2032(\u03d5)]\u00a0in\u00a0\u03a9</p> where WWW is a double-well potential defined by: <p>W(\u03d5)=\u03d52(1\u2212\u03d5)2 W(\\phi)=\\phi^2(1-\\phi)^2 W(\u03d5)=\u03d52(1\u2212\u03d5)2</p></p> <p>The objective is to recover the 1D hyperbolic tangent solution</p> <p>\u03d5(r,t=tend)=12+12tanh\u2061[2\u00d7(r\u2212(R/2))\u03f5] \\phi(r,t=t_{end}) = \\frac{1}{2}+\\frac{1}{2}\\tanh\\bigg[2\\times \\frac{(r - (R/2))}{ \\epsilon}\\bigg] \u03d5(r,t=tend\u200b)=21\u200b+21\u200btanh[2\u00d7\u03f5(r\u2212(R/2))\u200b]</p> <p>starting from hyperbolic tangent solution with a thinner interface \u03f50=\u03f5/10\\epsilon_0=\\epsilon/10\u03f50\u200b=\u03f5/10:</p> <p>\u03d5(r,t=0)=12+12tanh\u2061[2\u00d7(r\u2212(R/2)))\u03f50] \\phi(r,t=0) = \\frac{1}{2}+\\frac{1}{2}\\tanh\\bigg[2\\times \\frac{(r - (R/2)))}{ \\epsilon_0}\\bigg] \u03d5(r,t=0)=21\u200b+21\u200btanh[2\u00d7\u03f50\u200b(r\u2212(R/2)))\u200b]</p> <p>Neumann boundary conditions are prescribed on \u0393left\\Gamma_{left}\u0393left\u200b (r=0) and \u0393right\\Gamma_{right}\u0393right\u200b (r=R): <p>n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u0393left\u222a\u0393right {\\bf{n}} \\cdot{} \\lambda \\nabla \\phi=0 \\text{ on }\\Gamma_{left} \\cup \\Gamma_{right} n\u22c5\u03bb\u2207\u03d5=0\u00a0on\u00a0\u0393left\u200b\u222a\u0393right\u200b</p></p> <p>For this test, the following parameters are considered:</p> Parameter Symbol Value mobility coefficient M\u03d5M_\\phiM\u03d5\u200b 10\u2212510^{-5}10\u22125 energy gradient coefficient \u03bb\\lambda\u03bb 32\u03c3\u03f5\\frac{3}{2}\\sigma\\epsilon23\u200b\u03c3\u03f5 surface tension \u03c3\\sigma\u03c3 0.060.060.06 interface thickness \u03f5\\epsilon\u03f5 5\u00d710\u221245\\times10^{-4}5\u00d710\u22124 depth of the double-well potential \u03c9\\omega\u03c9 12\u03c3/\u03f512\\frac{\\sigma}/{\\epsilon}12/\u03c3\u200b\u03f5 <ul> <li>Time marching: Euler Implicit scheme, t\u2208[0,50]t\\in[0,50]t\u2208[0,50], \u03b4t=0.25\\delta t=0.25\u03b4t=0.25</li> <li>Spatial discretization: uniform mesh with N=30N=30N=30 elements </li> <li>Double-Well potential: implicit scheme</li> </ul>"},{"location":"Started/HowTo/Simple/index.html#structure-of-a-minimal-test-case","title":"Structure of a minimal test case","text":"<p><code>SLOTH</code> provides C++ packages that allows to build multiphysics simulations. </p> <p>Each <code>SLOTH</code> test is actually defined as a <code>main.cpp</code> file, which consists of four main parts:</p> <p>Global structure of a minimal test case</p> <pre><code>//---------------------------------------\n// 1/ Headers...\n//---------------------------------------\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // 1/ Aliases / Parallelism\n    //---------------------------------------\n\n    //---------------------------------------\n    // 2/ Geometry and Spatial discretization\n    //---------------------------------------\n\n    //---------------------------------------\n    // 3/ Multiphysics coupling scheme\n    //---------------------------------------\n\n    //---------------------------------------\n    // 4/ Time discretization\n    //---------------------------------------\n}\n</code></pre>"},{"location":"Started/HowTo/Simple/index.html#common","title":"Headers, Aliases &amp; Parallelism","text":"<p>Headers, aliases and parallelism features are the most general information that can be find in all test files. </p> <p>There are 3 main headers. </p> <ul> <li><code>kernel/sloth.hpp</code> groups all <code>SLOTH</code> dependencies</li> <li><code>mfem.hpp</code> groups all <code>mfem</code> dependencies</li> <li><code>tests/tests.hpp</code> groups all dependencies useful only for tests</li> </ul> <p>Test file with headers</p> <pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming mfem include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n\n}\n</code></pre> <p>Aliases facilitate the use of complex C++ types by providing a more concise alternative.  It should be noted that users may define additional aliases. However, those specified in this page pertain to all tests. </p> <p>Each alias employ a template structure for space dimension dependence (see <code>DIM</code> in the example).</p> <p>Test file with headers and common aliases</p> <pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming mfem include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // Common aliases\n    //---------------------------------------\n    const int DIM=1;\n    using FECollection = Test&lt;DIM&gt;::FECollection;\n    using PSTCollection = Test&lt;DIM&gt;::PSTCollection;\n    using VARS = Test&lt;DIM&gt;::VARS;\n    using VAR = Test&lt;DIM&gt;::VAR;\n    using PST = Test&lt;DIM&gt;::PST;\n    using SPA = Test&lt;DIM&gt;::SPA;\n    using BCS = Test&lt;DIM&gt;::BCS;    \n}\n</code></pre> <p>These aliases both refer to MFEM or <code>SLOTH</code> types used many times in the test file:</p> Alias Type Description <code>FECollection</code> <code>Test&lt;DIM&gt;::FECollection</code> Finite Element Space. H1\\cal{H}^1H1 by default (MFEM type) <code>PSTCollection</code> <code>Test&lt;DIM&gt;::PSTCollection</code> Type of post-processing. Paraview by default (MFEM type) <code>VARS</code> <code>Test&lt;DIM&gt;::VARS</code> Collection of Variable objects (SLOTH type) <code>VAR</code> <code>Test&lt;DIM&gt;::VAR</code> Variable object  (SLOTH type) <code>PST</code> <code>Test&lt;DIM&gt;::PST</code> PostProcessing (SLOTH type) <code>SPA</code> <code>Test&lt;DIM&gt;::SPA</code> Spatial Discretization (SLOTH type) <code>BCS</code> <code>Test&lt;DIM&gt;::BCS</code> Boundary Conditions (SLOTH type) <p>SLOTH's ambition is to be able to perform massively parallel computations  while logically retaining the ability to perform sequential computations.</p> <p>Only three lines of code must be defined in each test file for the MPI and HYPRE libraries.</p> <p>Test file with headers, common aliases and parallelism features</p> <pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming `MFEM` include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // Initialize MPI and HYPRE\n    //---------------------------------------\n    mfem::Mpi::Init(argc, argv);\n    mfem::Hypre::Init();\n    //---------------------------------------\n    // Common aliases\n    //---------------------------------------\n    const int DIM=1;\n    using FECollection = Test&lt;DIM&gt;::FECollection;\n    using VARS = Test&lt;DIM&gt;::VARS;\n    using VAR = Test&lt;DIM&gt;::VAR;\n    using PSTCollection = Test&lt;DIM&gt;::PSTCollection;\n    using PST = Test&lt;DIM&gt;::PST;\n    using SPA = Test&lt;DIM&gt;::SPA;\n    using BCS = Test&lt;DIM&gt;::BCS;\n\n\n    //---------------------------------------\n    // Finalize MPI\n    //---------------------------------------\n    mfem::Mpi::Finalize();\n}\n</code></pre>"},{"location":"Started/HowTo/Simple/index.html#spatial","title":"Spatial discretization","text":"<p>This part is dedicated the mesh (see Meshing) and the associated boundary conditions (see BoundaryConditions). </p> <p>Regarding the mesh, <code>SLOTH</code> enables to read meshes built with <code>GMSH</code> or to build a Cartesian mesh directly  in <code>MFEM</code>. The order of the Finite Elements and the level of mesh refinement must be also defined. </p> <p>Definition of a Finite Element mesh for <code>SLOTH</code> is made with a C++ object of type <code>SpatialDiscretization</code> or, more specifically for tests, by using the alias <code>SPA</code>.</p> <p>Extract of the test file with the definition of the mesh</p> <p><pre><code>auto refinement_level = 0;\nauto fe_order = 1;\nauto length = 1.e-3;\nauto nb_fe = 30;\nSPA spatial(\"InlineLineWithSegments\", fe_order, refinement_level, std::make_tuple(nb_fe, length));\n</code></pre> This example considers a 1D Finite Element mesh, without refinement (<code>refinement_level = 0</code>), built directly in <code>MFEM</code>.  The length of the domain is 111 mm (<code>length = 1.e-3</code>), divided into 303030 first order (<code>fe_order = 1</code>) elements (<code>nb_fe = 30</code>).</p> <p>All the functions used to create meshes are detailed in the Meshing section of the user manual. </p> <p>Regarding the boundary conditions, <code>SLOTH</code> enables to prescribe Dirichlet, Neumann and Periodic boundary conditions. </p> <p>Definition of boundary conditions for <code>SLOTH</code> is made with a C++ object of type <code>BoundaryConditions</code> or, more specifically for tests, by using the alias <code>BCS</code>.</p> <p>A <code>BCS</code>object is a collection of C++ objects of type <code>Boundary</code>. Each of them is associated to a geometrical boundary. The number of <code>Boundary</code> objects inside the <code>BCS</code> object must be equal to the total number of geometrical boundary. </p> <p>A <code>Boundary</code> object is defined by</p> <ul> <li>a name (C++ type `std::string'),</li> <li>an index (C++ type <code>int</code>),</li> <li>a type (C++ type `std::string') among \"Dirichlet\", \"Neumann\", \"Periodic\",</li> <li>a value (C++ type <code>double</code>), equal to zero by default.</li> </ul> <p>Extract of the test file with the mesh and its associated Neumann boundary conditions</p> <p><pre><code>    //---------------------------------------\n    // Meshing &amp; Boundary Conditions\n    //---------------------------------------\n    auto refinement_level = 0;\n    auto fe_order = 1;\n    auto length = 1.e-3;\n    auto nb_fe = 30;\n    SPA spatial(\"InlineLineWithSegments\", fe_order, refinement_level, std::make_tuple(nb_fe, length));\n\n    auto boundaries = {Boundary(\"left\", 0, \"Neumann\", 0.), Boundary(\"right\", 1, \"Neumann\", 0.)};\n    auto bcs = BCS(&amp;spatial, boundaries);\n</code></pre> This example consider Neumann boundary conditions both on the left and on the right of the domain.</p> <p>Different type of boundary conditions can be mixed as detailed in the Boundary Conditions section of the user manual. </p> <p>On the consistency of the indices of the boundaries</p> <p><code>MFEM v4.7</code> provides new features for referring to boundary attribute numbers. Such an improvement is not yet implemented in <code>SLOTH</code>. Consequently, users must take care to the consistency of the indices used in the test file with the indices defined when building the mesh with <code>GMSH</code>.</p> <p>Test file with the mesh and the boundary conditions</p> <pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming mfem include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // Initialize MPI and HYPRE\n    //---------------------------------------\n    mfem::Mpi::Init(argc, argv);\n    mfem::Hypre::Init();\n    //---------------------------------------\n    // Common aliases\n    //---------------------------------------\n    const int DIM=1;\n    using FECollection = Test&lt;DIM&gt;::FECollection;\n    using VARS = Test&lt;DIM&gt;::VARS;\n    using VAR = Test&lt;DIM&gt;::VAR;\n    using PSTCollection = Test&lt;DIM&gt;::PSTCollection;\n    using PST = Test&lt;DIM&gt;::PST;\n    using SPA = Test&lt;DIM&gt;::SPA;\n    using BCS = Test&lt;DIM&gt;::BCS;\n    //---------------------------------------\n    // Meshing &amp; Boundary Conditions\n    //---------------------------------------\n    auto refinement_level = 0;\n    auto fe_order = 1;\n    auto length = 1.e-3;\n    auto nb_fe = 30;\n    SPA spatial(\"InlineLineWithSegments\", fe_order, refinement_level, std::make_tuple(nb_fe, length));\n    auto boundaries = {Boundary(\"left\", 0, \"Neumann\", 0.), Boundary(\"right\", 1, \"Neumann\", 0.)};\n    auto bcs = BCS(&amp;spatial, boundaries);\n    //---------------------------------------\n    // Finalize MPI\n    //---------------------------------------\n    mfem::Mpi::Finalize();\n}\n</code></pre>"},{"location":"Started/HowTo/Simple/index.html#coupling","title":"Multiphysics coupling scheme","text":"<p>This part is the core of the test file with the definition of the targeted physical problems (eg. equations, variational formulations, variables, coefficients) gathered inside a <code>Coupling</code> object. </p> <p>This implies many C++ objects designed specifically for <code>SLOTH</code>.  The main one is the <code>Problem</code> object defined as a collection of C++ objects of interest for <code>SLOTH</code>:</p> <ul> <li>a <code>Variables</code> object,</li> <li>an <code>Operator</code> object, </li> <li>a <code>PostProcessing</code> object.</li> </ul> <p>Regarding the <code>Variables</code>, <code>SLOTH</code> differentiates between primary variables, that are solved directly by the problem (eg. the order parameter for the Allen-Cahn equation, the order parameter and the chemical potential for the Cahn-Hilliard equation), and secondary variables, which are derived from another problem to ensure multiphysics coupling (eg. the order parameter in the heat transfer equation, the temperature in the Allen-Cahn equation). </p> <p>Despite their different purposes, the definition of primary and auxiliary variables are consistent and made with a C++ object of type <code>Variables</code> (see the alias <code>VARS</code>).  <code>Variables</code> is simply a collection of <code>Variable</code> object (see the alias <code>VAR</code>) defined by:</p> <ul> <li>the spatial discretisation (ie. the <code>SPA</code>object), </li> <li>a set of boundary conditions (ie the <code>BCS</code> object), </li> <li>a name (C++ type <code>std::string</code>), </li> <li>a storage depth level (C++ type <code>int</code>), </li> <li>an initial condition,</li> <li>an analytical solution (optional). </li> </ul> <p>Definition of variables with an analytical solution</p> <p>The presence of an analytical solution automatically enables the calculation of the  L2L^2L2 error over the domain. </p> <p>Whether it's an initial condition or an analytical solution, the users can define them with a constant, a C++ object of type <code>std::function</code> or a C++ object of type <code>AnalyticalFunctions</code>. </p> <p>It is recommended to read the page dedicated to <code>Variables</code> in the user manual for more details about the use and the different definitions of this <code>SLOTH</code> object.</p> <p><code>AnalyticalFunctions</code> enable to use pre-defined mathematical functions currently used in the studies conducted with <code>SLOTH</code>. </p> <p>If the mathematical expression is not yet available, the users can define it with a C++ object of type <code>std::function</code>.</p> <p>Extract of the test file with Variables</p> <p><pre><code>    //---------------------------------------\n    // Multiphysics coupling scheme\n    //---------------------------------------     \n    //--- Variables\n    const auto&amp; center_x = 0.;\n    const auto&amp; a_x = 1.;\n    const auto&amp; thickness = 5.e-5;\n    const auto&amp; radius = 5.e-4;\n\n    std::string variable_name = \"phi\";\n    int level_of_storage= 2;\n\n    auto initial_condition = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, 2.*epsilon, radius);\n    auto analytical_solution = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, epsilon, radius);\n    auto vars = VARS(VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition, analytical_solution));\n</code></pre> This example defines a single primary variable, named \"phi\" with two levels of storage.  The initial condition and the analytical solution are of the hyperbolic tangent type.</p> <p>Another class of major C++ objects for <code>SLOTH</code> is <code>Operator</code>.  These objects allow the solution of the algebraic system resulting from the discretization of the (non-linear) equations.  For each of them, the users can find a stationary and a transient version.  This is detailed in the <code>Partial Differential Equations</code> page of the user manual. Although the input arguments provided to the <code>Operator</code> object are of interest, the focus is rather on the definition of the C++ object itself, which requires the input of the variational formulation of the equations.  This specificity is implemented on the basis of <code>NonLinearFormIntegrators</code> objects, also detailed in the user manual in the <code>Partial Differential Equations</code> page.  The definition of the integrators obviously depends on the targeted problem.  In the present example, the variational formulation is defined by using the <code>AllenCahnNLFormIntegrator</code> object.  This is the most general form of integrator for Allen-Cahn problems.</p> <p>Extract of the test file with Operators and Integrators</p> <pre><code>    //--- Integrator : alias definition for the sake of clarity\n    using NLFI = AllenCahnNLFormIntegrator&lt;VARS, ThermodynamicsPotentialDiscretization::Implicit, ThermodynamicsPotentials::W, Mobility::Constant&gt;;\n\n    //--- Operator definition\n    //  Interface thickness\n    const auto&amp; epsilon(5.e-4);\n    // Interfacial energy\n    const auto&amp; sigma(6.e-2);\n    // Two-phase mobility\n    const auto&amp; mob(1.e-5);\n    const auto&amp; lambda = 3. * sigma * epsilon / 2.;\n    const auto&amp; omega = 12. * sigma / epsilon;\n    auto params = Parameters(Parameter(\"epsilon\", epsilon), Parameter(\"sigma\", sigma), Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));\n\n    std::vector&lt;SPA*&gt; spatials{&amp;spatial};\n    AllenCahnOperator&lt;FECollection, DIM, NLFI&gt; oper(spatials, params, TimeScheme::EulerImplicit);\n</code></pre> <p>Use of <code>Parameters</code> and <code>Parameter</code> objects</p> <p><code>Parameters</code> is a C++ object designed for <code>SLOTH</code> and defined as a collection of <code>Parameter</code> objects. The latter is also a C++ object specially developed for <code>SLOTH</code>.  It enables the definition of a variable which can be of different C++ types. It is based on the <code>std::variant</code> type. Users are referred to the <code>Parameters</code> page in the user manual for more details about the definition and the use of these objects.</p> <p>The results of <code>SLOTH</code> simulations can be exported to VTK format and can be read with Paraview. This is possible by using the C++ object <code>PSTCollection</code> or, more specifically for tests, by using the alias <code>PST</code>.  This C++ object requires the knowledge of the mesh and a number of parameters to define, at least, the directories in which the results are stored and the frequency of storage.  All these parameters are detailed in the page PostProcessing.  By default, all primary variables associated with a <code>SLOTH</code> <code>Problem</code> are saved.</p> <p>Extract of the test file with PostProcessing</p> <p><pre><code>    //--- Post-Processing \n    const std::string&amp; main_folder_path = \"Saves\";\n    std::string calculation_path = \"AllenCahn\";\n    const auto&amp; frequency = 1;\n    auto pst_parameters = Parameters(Parameter(\"main_folder_path\", main_folder_path), Parameter(\"calculation_path\", calculation_path), Parameter(\"frequency\", frequency));\n    auto pst = PST(&amp;spatial, pst_parameters);\n</code></pre> In this example, the results will be saved in the <code>Saves/AllenCahn</code> directory (see <code>Parameter(\"main_folder_path\", main_folder_path)</code> and  <code>Parameter(\"calculation_path\", calculation_path)</code>), at each time-step (see <code>Parameter(\"frequency\", frequency)</code>).</p> <p>At this stage,  the <code>SLOTH</code> <code>Problem</code> can be defined and, as previously explained, collected in a <code>Coupling</code> object.  This is illustrated in the following example (see <code>Problem&lt;OPE, VARS, PST&gt; ac_problem</code> and  <code>Coupling(\"Main coupling\", ac_problem)</code>). </p> <p>Test file with Variables, Operators and Integrators and Post-Processing</p> <p><pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming mfem include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // Initialize MPI and HYPRE\n    //---------------------------------------\n    mfem::Mpi::Init(argc, argv);\n    mfem::Hypre::Init();\n    //---------------------------------------\n    // Common aliases\n    //---------------------------------------\n    const int DIM=1;\n    using FECollection = Test&lt;DIM&gt;::FECollection;\n    using VARS = Test&lt;DIM&gt;::VARS;\n    using VAR = Test&lt;DIM&gt;::VAR;\n    using PSTCollection = Test&lt;DIM&gt;::PSTCollection;\n    using PST = Test&lt;DIM&gt;::PST;\n    using SPA = Test&lt;DIM&gt;::SPA;\n    using BCS = Test&lt;DIM&gt;::BCS;\n    //---------------------------------------\n    // Meshing &amp; Boundary Conditions\n    //---------------------------------------\n    auto refinement_level = 0;\n    auto fe_order = 1;\n    auto length = 1.e-3;\n    auto nb_fe = 30;\n    SPA spatial(\"InlineLineWithSegments\", fe_order, refinement_level, std::make_tuple(nb_fe, length));\n    auto boundaries = {Boundary(\"left\", 0, \"Neumann\", 0.), Boundary(\"right\", 1, \"Neumann\", 0.)};\n    auto bcs = BCS(&amp;spatial, boundaries);\n\n    //---------------------------------------\n    // Multiphysics coupling scheme\n    //---------------------------------------     \n    //--- Variables\n    const auto&amp; center_x = 0.;\n    const auto&amp; a_x = 1.;\n    const auto&amp; thickness = 5.e-5;\n    const auto&amp; radius = 5.e-4;\n\n    std::string variable_name = \"phi\";\n    int level_of_storage= 2;\n\n    auto initial_condition = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, 2.*epsilon, radius);\n    auto analytical_solution = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, epsilon, radius);\n    auto vars = VARS(VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition, analytical_solution));\n\n    //--- Integrator : alias definition for the sake of clarity\n    using NLFI = AllenCahnNLFormIntegrator&lt;VARS, ThermodynamicsPotentialDiscretization::Implicit, ThermodynamicsPotentials::W, Mobility::Constant&gt;;\n\n    //--- Operator definition\n    //  Interface thickness\n    const auto&amp; epsilon(5.e-4);\n    // Interfacial energy\n    const auto&amp; sigma(6.e-2);\n    // Two-phase mobility\n    const auto&amp; mob(1.e-5);\n    const auto&amp; lambda = 3. * sigma * epsilon / 2.;\n    const auto&amp; omega = 12. * sigma / epsilon;\n    auto params = Parameters(Parameter(\"epsilon\", epsilon), Parameter(\"sigma\", sigma), Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));\n\n    std::vector&lt;SPA*&gt; spatials{&amp;spatial};\n    AllenCahnOperator&lt;FECollection, DIM, NLFI&gt; oper(&amp;spatial, params, TimeScheme::EulerImplicit);\n\n    //--- Post-Processing \n    const std::string&amp; main_folder_path = \"Saves\";\n    std::string calculation_path = \"AllenCahn\";\n    const auto&amp; frequency = 1;\n    auto pst_parameters = Parameters(Parameter(\"main_folder_path\", main_folder_path), Parameter(\"calculation_path\", calculation_path), Parameter(\"frequency\", frequency));\n    auto pst = PST(&amp;spatial, pst_parameters);\n\n    //-----------------------\n    // Problem\n    //-----------------------\n    Problem&lt;AllenCahnOperator&lt;FECollection, DIM, NLFI&gt;, VARS, PST&gt; ac_problem(oper, vars, pst);\n    //-----------------------\n    // Coupling\n    //-----------------------\n    auto main_coupling = Coupling(\"Main coupling\", ac_problem);\n\n    //---------------------------------------\n    // Finalize MPI\n    //---------------------------------------\n    mfem::Mpi::Finalize();\n}\n</code></pre> In this example, a coupling, labelled <code>Main coupling</code>, is defined with only one <code>SLOTH</code> <code>Problem</code> associated with the solution of Allen-Cahn equation.</p> <p>Users are referred to the MultiPhysicsCouplingScheme page of the user manual for more details about the available <code>SLOTH</code> problems and how to use them.</p>"},{"location":"Started/HowTo/Simple/index.html#time","title":"Time discretization","text":"<p>Time discretization is the last main part of a test file.  It corresponds to the C++ object <code>TimeDiscretization</code> defined as a number of parameters and the <code>Coupling</code> objects specially designed for the current <code>SLOTH</code> simulation. Among these parameters, there are the initial time, the final time and the uniform value of the time-step.  The method <code>solve</code> must be explicitly called to run the calculation. This is detailed in the <code>Time</code> page of the user manual.</p> <p>Extract of the test file with TimeDiscretization</p> <p><pre><code>    //---------------------------------------\n    // Time discretization\n    //--------------------------------------- \n    const auto&amp; t_initial = 0.0;\n    const auto&amp; t_final = 50.0;\n    const auto&amp; dt = 0.01;\n    auto time_parameters = Parameters(Parameter(\"initial_time\", t_initial), Parameter(\"final_time\", t_final), Parameter(\"time_step\", dt));\n    auto time = TimeDiscretization(time_parameters, main_coupling);\n\n    time.solve();\n</code></pre> In this example, the simulation is performed during 505050 s with a time-step equal to 0.010.010.01 s.</p>"},{"location":"Started/HowTo/Simple/index.html#comprehensive-test-file","title":"Comprehensive test file","text":"<p>Test file with Variables, Operators and Integrators, Post-Processing, Physical Convergence and Time Discretization</p> <pre><code>//---------------------------------------\n// Headers\n//---------------------------------------\n#include \"kernel/sloth.hpp\"\n#include \"mfem.hpp\"  // NOLINT [no include the directory when naming mfem include file]\n#include \"tests/tests.hpp\"\n\nint main(int argc, char* argv[]) {\n    //---------------------------------------\n    // Initialize MPI and HYPRE\n    //---------------------------------------\n    mfem::Mpi::Init(argc, argv);\n    mfem::Hypre::Init();\n    //---------------------------------------\n    // Common aliases\n    //---------------------------------------\n    const int DIM = 1\n    using FECollection = Test&lt;DIM&gt;::FECollection;\n    using VARS = Test&lt;DIM&gt;::VARS;\n    using VAR = Test&lt;DIM&gt;::VAR;\n    using PSTCollection = Test&lt;DIM&gt;::PSTCollection;\n    using PST = Test&lt;DIM&gt;::PST;\n    using SPA = Test&lt;DIM&gt;::SPA;\n    using BCS = Test&lt;DIM&gt;::BCS;\n    //---------------------------------------\n    // Meshing &amp; Boundary Conditions\n    //---------------------------------------\n    auto refinement_level = 0;\n    auto fe_order = 1;\n    auto length = 1.e-3;\n    auto nb_fe = 30;\n    SPA spatial(\"InlineLineWithSegments\", fe_order, refinement_level, std::make_tuple(nb_fe, length));\n    auto boundaries = {Boundary(\"left\", 0, \"Neumann\", 0.), Boundary(\"right\", 1, \"Neumann\", 0.)};\n    auto bcs = BCS(&amp;spatial, boundaries);\n\n    //---------------------------------------\n    // Multiphysics coupling scheme\n    //---------------------------------------     \n    //--- Variables\n    const auto&amp; center_x = 0.;\n    const auto&amp; a_x = 1.;\n    const auto&amp; thickness = 5.e-5;\n    const auto&amp; radius = 5.e-4;\n\n    std::string variable_name = \"phi\";\n    int level_of_storage= 2;\n\n    auto initial_condition = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, 2.*epsilon, radius);\n    auto analytical_solution = AnalyticalFunctions&lt;DIM&gt;(AnalyticalFunctionsType::from(\"HyperbolicTangent\"), center_x, a_x, epsilon, radius);\n    auto vars = VARS(VAR(&amp;spatial, bcs, variable_name, level_of_storage, initial_condition, analytical_solution));\n\n    //--- Integrator : alias definition for the sake of clarity\n    using NLFI = AllenCahnNLFormIntegrator&lt;VARS, ThermodynamicsPotentialDiscretization::Implicit, ThermodynamicsPotentials::W, Mobility::Constant&gt;;\n\n    //--- Operator definition\n    //  Interface thickness\n    const auto&amp; epsilon(5.e-4);\n    // Interfacial energy\n    const auto&amp; sigma(6.e-2);\n    // Two-phase mobility\n    const auto&amp; mob(1.e-5);\n    const auto&amp; lambda = 3. * sigma * epsilon / 2.;\n    const auto&amp; omega = 12. * sigma / epsilon;\n    auto params = Parameters(Parameter(\"epsilon\", epsilon), Parameter(\"sigma\", sigma), Parameter(\"lambda\", lambda), Parameter(\"omega\", omega));\n\n    std::vector&lt;SPA*&gt; spatials{&amp;spatial};\n    AllenCahnOperator&lt;FECollection, DIM, NLFI&gt; oper(spatials, params, TimeScheme::EulerImplicit);\n\n    //--- Post-Processing \n    const std::string&amp; main_folder_path = \"Saves\";\n    std::string calculation_path = \"AllenCahn\";\n    const auto&amp; frequency = 1;\n    auto pst_parameters = Parameters(Parameter(\"main_folder_path\", main_folder_path), Parameter(\"calculation_path\", calculation_path), Parameter(\"frequency\", frequency));\n    auto pst = PST(&amp;spatial, pst_parameters);\n\n    //-----------------------\n    // Problem\n    //-----------------------\n    Problem&lt;AllenCahnOperator&lt;FECollection, DIM, NLFI&gt;, VARS, PST&gt; ac_problem(oper, vars, pst);\n    //-----------------------\n    // Coupling\n    //-----------------------\n    auto main_coupling = Coupling(\"Main coupling\", ac_problem);\n\n    //---------------------------------------\n    // Time discretization\n    //--------------------------------------- \n    const auto&amp; t_initial = 0.0;\n    const auto&amp; t_final = 50.0;\n    const auto&amp; dt = 0.01;\n    auto time_parameters = Parameters(Parameter(\"initial_time\", t_initial), Parameter(\"final_time\", t_final), Parameter(\"time_step\", dt));\n    auto time = TimeDiscretization(time_parameters, main_coupling);\n\n    time.solve();\n\n    //---------------------------------------\n    // Finalize MPI\n    //---------------------------------------\n    mfem::Mpi::Finalize();\n}\n</code></pre>"},{"location":"Started/HowTo/Tutorials/index.html","title":"Tutorials (coming soon)","text":"<p>This page will provide tips and tricks for specific <code>SLOTH</code> features. </p>"},{"location":"Started/Installation/index.html","title":"Installation guide","text":"<p><code>SLOTH</code> is written in <code>C++17</code>/<code>C++20</code>. It can be built under Linux and MacOS using <code>CMake</code>.  The main prerequisite is the <code>MFEM</code> Finite Element library developed in C++ by LLNL<sup>1</sup>.</p> <p><code>MFEM</code> can be installed in several ways but the use of <code>spack</code> on Linux and <code>Homebrew</code>on MacOS is recommended for sake of simplicity.</p> <p>Installing <code>SLOTH</code> therefore consists of first installing <code>MFEM</code> and compiling <code>SLOTH</code>.  The basic procedure is then provided for the Linux platforms using spack, the Linux platforms from source files and the MacOs platforms, but also for supercomputers where <code>SLOTH</code> is intended to be used.</p> <p>For certain applications, <code>SLOTH</code> utilizes C++ APIs contained within the library <code>libTorch</code> to load <code>PyTorch</code> models. The basic procedure also includes instructions for installing <code>libTorch</code>.</p> <ol> <li> <p>Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell, Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron Fisher, Tzanio Kolev, and others. Mfem: a modular finite element methods library. Computers &amp; Mathematics with Applications, 81:42\u201374, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Started/Installation/cluster.html","title":"Cluster","text":""},{"location":"Started/Installation/cluster.html#installing-sloth-on-supercomputers-without-internet-access","title":"Installing SLOTH On Supercomputers Without Internet Access","text":"<p>This guide provides detailed steps to install SLOTH on a supercomputer without internet access using provided scripts. It includes using Spack for package management and compiling dependencies required by SLOTH.</p> <p>Installing SLOTH on a supercomputer without internet access involves preparing the environment, downloading necessary components, creating a local Spack mirror, and building SLOTH with all dependencies.</p>"},{"location":"Started/Installation/cluster.html#use-and-adapt-scripts","title":"Use And Adapt Scripts","text":"<p>The installation is performed in two main parts using the scripts provided below:</p> <ol> <li><code>sloth-topaze-part1.sh</code>: Prepares the environment and creates an archive of necessary components.</li> <li><code>sloth-topaze-part2.sh</code>: Sets up Spack and compiles SLOTH on the target supercomputer.</li> </ol> <p>Make sure to adapt the environment variables in the scripts (e.g., <code>MY_LOG</code>, <code>DEST_DIR</code>) to your specific user settings.</p> <p>On your local machine:</p> <pre><code>source sloth-topaze-part1.sh\n</code></pre> <p>On your distant machine (Topaze in our example)</p> <pre><code>sloth-topaze-part2.sh\n</code></pre>"},{"location":"Started/Installation/cluster.html#part-1-preparing-the-environment-sloth-topaze-part1sh","title":"Part 1: Preparing the Environment (<code>sloth-topaze-part1.sh</code>)","text":"<p>This script is designed to be run on a local machine with internet access. It sets up the environment, clones necessary repositories, prepares Spack, and packages everything into an archive for transfer to the supercomputer.</p>"},{"location":"Started/Installation/cluster.html#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<ol> <li>Define Root and Working Directories: <pre><code>export ROOT_DIR=$PWD\nmkdir -p sloth-topaze-dir &amp;&amp; cd sloth-topaze-dir\nexport WORK_DIR=$ROOT_DIR/sloth-topaze-dir\nexport MY_LOG=your_login      # Replace with your Topaze login\nexport DEST_DIR=/path/to/destination # Replace with your destination directory\n</code></pre></li> <li><code>ROOT_DIR</code> is set to the current directory.</li> <li>Creates a subdirectory <code>sloth-topaze-dir</code> where all operations will occur.</li> <li><code>WORK_DIR</code> is set to the path of <code>sloth-topaze-dir</code>.</li> <li> <p><code>MY_LOG</code> and <code>DEST_DIR</code> are placeholders for your supercomputer login and destination directory. You need to replace these with your actual login and path on the supercomputer.</p> </li> <li> <p>Clone Spack Repository: <pre><code>echo \"Getting Spack ...\"\nif [ ! -d \"spack\" ]; then\n    git clone --depth=2 --branch=v0.23.0 https://github.com/spack/spack.git\nfi\nexport SPACK_ROOT=$PWD/spack\nrm -r ~/.spack\nsource ${SPACK_ROOT}/share/spack/setup-env.sh\n</code></pre></p> </li> <li>Clones Spack from GitHub.</li> <li>Sets <code>SPACK_ROOT</code> to the path of the cloned Spack directory.</li> <li>Removes any existing <code>.spack</code> configuration to ensure a clean setup.</li> <li> <p>Sources the Spack environment to set up paths and commands for use.</p> </li> <li> <p>Clone SLOTH Repository: <pre><code>echo \"Getting PLEIADES/SLOTH ...\"\nif [ ! -d \"sloth\" ]; then\n    git clone [https://www-git-cad.intra.cea.fr/DEC/collaboratif/ci230846/DEV_PROJECT/sloth.git](https://github.com/Collab4Sloth/SLOTH.git)\nfi\n</code></pre></p> </li> <li> <p>Similar to Spack, this step clones the SLOTH repository if it doesn't already exist in the working directory.</p> </li> <li> <p>Create a Spack Bootstrap Mirror: <pre><code>spack bootstrap mirror --binary-packages my_bootstrap\n</code></pre></p> </li> <li> <p>Creates a bootstrap mirror that includes binary packages of the basic build tools that Spack needs to work offline.</p> </li> <li> <p>Create a Specific Spack Mirror for Dependencies: <pre><code>spack mirror create -d mirror-mfem -D gcc@11.2.0 mfem+mpi+debug+openmp+petsc+strumpack+suite-sparse+sundials+superlu-dist+miniapps%gcc@11.2.0\n</code></pre></p> </li> <li>Creates a mirror named <code>mirror-mfem</code> for all specified dependencies (<code>mfem</code>, <code>petsc</code>, etc.), ensuring that Spack can access these packages without internet access on the supercomputer.</li> <li> <p>You can add extra packages here.</p> </li> <li> <p>Package and Transfer Files: <pre><code>cd $ROOT_DIR\ntar cvf archive.tar.gz sloth-topaze-dir/\nscp archive.tar.gz $MY_LOG@topaze.ccc.cea.fr:$DEST_DIR/\n</code></pre></p> </li> <li>Archives the entire <code>sloth-topaze-dir</code> directory into <code>archive.tar.gz</code>.</li> <li>Uses <code>scp</code> to securely copy this archive to the specified destination directory on the supercomputer. Replace <code>topaze.ccc.cea.fr</code> with the appropriate hostname if needed.</li> </ol>"},{"location":"Started/Installation/cluster.html#part-2-setting-up-and-building-sloth-sloth-topaze-part2sh","title":"Part 2: Setting Up and Building SLOTH (<code>sloth-topaze-part2.sh</code>)","text":"<p>This script is run on the supercomputer. It unpacks the archive, sets up the Spack environment, configures Spack to work offline, and builds SLOTH with all required dependencies.</p>"},{"location":"Started/Installation/cluster.html#step-by-step-breakdown_1","title":"Step-by-Step Breakdown","text":"<ol> <li>Define Directories: <pre><code>export DEST_DIR=$PWD\nexport WORK_DIR=$DEST_DIR/sloth-topaze-dir\n</code></pre></li> <li><code>DEST_DIR</code> is set to the current working directory (where the archive was transferred).</li> <li> <p><code>WORK_DIR</code> points to the <code>sloth-topaze-dir</code> directory inside <code>DEST_DIR</code>.</p> </li> <li> <p>Clean Up and Extract the Archive: <pre><code>rm -r ~/.spack\ncd $DEST_DIR\ntar xvf archive.tar.gz\ncd $WORK_DIR\n</code></pre></p> </li> <li>Removes any existing Spack configuration (<code>~/.spack</code>) to ensure a fresh environment setup.</li> <li> <p>Extracts the archive (<code>archive.tar.gz</code>) containing all previously prepared files.</p> </li> <li> <p>Set Up Spack Environment: <pre><code>source $WORK_DIR/spack/share/spack/setup-env.sh\nspack bootstrap reset -y\nspack bootstrap add --scope=site --trust local-binaries $PWD/my_bootstrap/metadata/binaries/\nspack bootstrap add --scope=site --trust local-sources $PWD/my_bootstrap/metadata/sources/\nspack bootstrap disable --scope=site github-actions-v0.5\nspack bootstrap disable --scope=site github-actions-v0.4\nspack bootstrap disable --scope=site spack-install\nspack bootstrap root $PWD/spack/bootstrap\nspack bootstrap now\nspack bootstrap status\n</code></pre></p> </li> <li>Sources the Spack environment to set up the paths and commands.</li> <li>Resets Spack\u2019s bootstrap configuration and adds the local bootstrap mirror (<code>my_bootstrap</code>) created earlier, ensuring all dependencies are fetched locally.</li> <li>Disables unnecessary bootstrap sources (<code>github-actions-v0.5</code>, etc.) to avoid any attempt to connect online.</li> <li> <p>Sets the root path for Spack\u2019s bootstrap environment and checks the status.</p> </li> <li> <p>Set Compiler and Environment Variables: <pre><code>export CC='gcc'\nexport CXX='g++'\nexport FC='mpifort'\nexport OMPI_CC='gcc'\nexport OMPI_CXX='g++'\nexport OMPI_FC='gfortran'\n</code></pre></p> </li> <li>Specifies compilers for C, C++, and Fortran, ensuring the correct toolchain is used during the build.</li> <li> <p>Sets OpenMPI environment variables to link the compilers correctly.</p> </li> <li> <p>Load Required Modules and Add Spack Mirror: <pre><code>module load gnu/11.2.0 mpi cmake/3.29.6 \nspack mirror add SLOTH $WORK_DIR/mirror-mfem/\nspack compiler find\nspack external find openmpi\nspack external find cmake\nspack external find openssh\n</code></pre></p> </li> <li>Loads necessary modules (<code>gnu</code>, <code>mpi</code>, <code>cmake</code>) to provide the required tools and compilers.</li> <li>Adds the previously created Spack mirror (<code>mirror-mfem</code>) so that dependencies are fetched from the local mirror instead of the internet.</li> <li> <p>Detects and registers available compilers and external software (e.g., <code>openmpi</code>, <code>cmake</code>, <code>openssh</code>) within Spack.</p> </li> <li> <p>Install Dependencies and Build SLOTH: <pre><code>spack install gcc@11.2.0 mfem+mpi+debug+openmp+petsc+strumpack+suite-sparse+sundials+superlu-dist+miniapps%gcc@11.2.0\ncd $WORK_DIR/sloth\nmkdir build &amp;&amp; cd build\nspack load mfem\nspack load metis\nexport HYPRE_DIR=`spack location -i hypre`\nexport MPI_DIR=`spack location -i mpi`\nexport METIS_DIR=`spack location -i metis`\n\ncmake .. -DMFEM_USE_PETSC=ON -DPETSC_DIR=${PETSC_DIR} -DPETSC_ARCH=\"\" -DPETSC_INCLUDES=${PETSC_DIR}/include -DPETSC_LIBRARIES=${PETSC_DIR}/lib -DPETSC_EXECUTABLE_RUNS=${PETSC_DIR}/bin\nmake -j 10\nctest\n</code></pre></p> </li> <li>Installs GCC and other specified dependencies from the local mirror without accessing the internet.</li> <li>Sets up the build directory within the SLOTH repository (<code>build</code>).</li> <li>Loads required dependencies (<code>mfem</code>, <code>metis</code>) to ensure they are available for the build process.</li> <li>Sets environment variables to locate specific dependency installations.</li> <li>Configures SLOTH with <code>cmake</code>, pointing to relevant dependencies (<code>PETSC</code>, etc.), and builds the software using <code>make</code>.</li> <li>Runs tests with <code>ctest</code> to verify the build.</li> </ol>"},{"location":"Started/Installation/cluster.html#run-your-simulation-on-topaze","title":"Run Your Simulation On Topaze","text":"<p>Script example of a simulation running on milan partition over 8192 mpi processes with a duration limit of about 24 hours:</p> <pre><code>#!/bin/bash\n#MSUB -r sloth_big_run\n#MSUB -n 8192\n#MSUB -c 1\n#MSUB -T 86000\n#MSUB -m scratch\n#MSUB -o sloth_big_run_%I.o\n#MSUB -e sloth_big_run_%I.e\n#MSUB -q milan\n\nset -x\nexport OMP_NUM_THREADS=1\nccc_mprun ./test3D\n</code></pre>"},{"location":"Started/Installation/cluster_source.html","title":"Cluster from source files","text":"<p>The following installation procedure describes how to install <code>SLOTH</code> from source files on a supercomputer. Here, the description is based on an installation done on CCRT Topaze.</p> <p>This procedure is mainly based on the installation procedure from source files on local computer. </p>"},{"location":"Started/Installation/cluster_source.html#getting-source-files-on-local-computer","title":"Getting source files on local computer","text":"<p>The first step consists in cloning <code>MFEM</code>, <code>METIS</code>, <code>HYPRE</code> and <code>SuiteSparse</code>.</p> <p>Clone of the default branch</p> <ul> <li>The current installation procedure assumes that the clone of the source files is based on the default branch of each repository.</li> <li>Users are free to consider different branches for their installation.</li> </ul> <p>All sources are collected in a global directory called <code>MFEM4SLOTH</code>. </p> <pre><code>cd $HOME\nmkdir MFEM4SLOTH\ncd MFEM4SLOTH\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#mfem","title":"MFEM","text":"<p>MFEM's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/mfem/mfem.git\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#hypre","title":"HYPRE","text":"<p>HYPRE's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/hypre-space/hypre.git\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#metis","title":"METIS","text":"<p>METIS's source files are obtained by running the following commands:</p> <pre><code>git clone https://github.com/mfem/tpls.git\nmv tpls/metis-4.0.3.tar.gz .\ntar -zxvf metis-4.0.3.tar.gz\nrm -fr metis-4.0.3.tar.gz tpls\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#suitesparse","title":"SuiteSparse","text":"<p>SuiteSparse's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/DrTimothyAldenDavis/SuiteSparse.git\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#copy-of-source-files-on-the-supercomputer","title":"Copy of source files on the supercomputer","text":"<p>Copy of the <code>MFEM4SLOTH</code> folder on the supercomputer by running the following command:</p> <pre><code>rsync --info=progress2 -e ssh -avz MFEM4SLOTH &lt;login&gt;@&lt;remote_host&gt;:$DEST_DIR\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#building-dependencies-on-the-supercomputer","title":"Building dependencies on the supercomputer","text":"<p>The second step consists in building <code>METIS</code>, <code>HYPRE</code> and <code>SuiteSparse</code> on the supercomputer.  From now, all command are run on the supercomputer. </p>"},{"location":"Started/Installation/cluster_source.html#load-required-modules","title":"Load required modules","text":"<p>Before building dependencies, it is necessary to load some modules. Please keep in mind that versions depend on the targeted environment. </p> <p><code>gnu</code>, <code>mpi</code>, <code>cmake</code> are required to build MFEM with <code>METIS</code>, <code>HYPRE</code> and <code>SuiteSparse</code>.  For <code>SuiteSparse</code>, <code>blas</code> and <code>mpfr</code> are also needed.</p> <pre><code>module load gnu/11.1.0\nmodule load mpi/openmpi/4.1.4\nmodule load cmake/3.29.6\nmodule load blas/openblas/0.3.26\nmodule load mpfr/4.2.0\n</code></pre> <p>Find available modules</p> <p>The list of available modules can be obtained using the following command: <pre><code>module avail [optional_string]\n</code></pre> where an optional string can be specified to refine the search for modules.  This string can be a partial name. </p>"},{"location":"Started/Installation/cluster_source.html#metis_1","title":"METIS","text":"<p>To build <code>METIS</code>, the following command must be run:</p> <pre><code>cd metis-4.0.3\nmake OPTFLAGS=-Wno-error=implicit-function-declaration\nmkdir include\ncp Lib/*.h include/\ncd ..\nln -s metis-4.0.3 metis-4.0\n</code></pre> <p>The fourth instruction differs from the installation procedure from source files on local computer. </p>"},{"location":"Started/Installation/cluster_source.html#hypre_1","title":"HYPRE","text":"<p>To build <code>HYPRE</code>, the following command must be run:</p> <p><pre><code>cd hypre/src\n./configure --disable-fortran\nmake -j N\ncd ../..\n</code></pre> where <code>N</code> is a user defined number of CPUs.</p>"},{"location":"Started/Installation/cluster_source.html#suitesparse_1","title":"SuiteSparse","text":"<p>To build <code>SuiteSparse</code>, the following commands must be run:</p> <p><pre><code>cd SuiteSparse/\nmake -j N\nmake install DESTDIR=$PWD/INSTALLDIR\nmv INSTALLDIR/usr/local/lib64/* lib/\nmv INSTALLDIR/usr/local/include/suitesparse/* include/\nmv INSTALLDIR/usr/local/bin/* bin/\ncd ..\n</code></pre> where <code>N</code> is a user defined number of CPUs.</p> <p>The fourth instruction differs from the installation procedure from source files on local computer. </p>"},{"location":"Started/Installation/cluster_source.html#building-mfem-with-dependencies","title":"Building MFEM with dependencies","text":"<p>Here, we assume that all dependencies are well built according to the previous directives.  At this stage, <code>MFEM</code> can be installed by running the following commands:</p> <pre><code>cd mfem\nmake -j N parallel MFEM_USE_SUITESPARSE=YES \nmake install PREFIX=INSTALLDIR\ncd ..\n</code></pre>"},{"location":"Started/Installation/cluster_source.html#sloth-compilation","title":"SLOTH compilation","text":"<p>Once <code>MFEM</code> is installed, priori to compile <code>SLOTH</code>, several environment variables must be defined:</p> <pre><code>    export MFEM_DIR=\"$MFEM4SLOTH/mfem/INSTALLDIR/\"\n    export HYPRE_DIR=\"$MFEM4SLOTH/hypre/src/hypre/\"\n    export METIS_DIR=\"$MFEM4SLOTH/metis-4.0/\"\n    export SuiteSparse_DIR=\"$MFEM4SLOTH/SuiteSparse/\"\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the <code>SLOTH</code> repository.  The use of this file is recommended to load the <code>MFEM</code> environment before compilling <code>SLOTH</code>.</p> <ul> <li>Load the <code>SLOTH</code> configuration file: <pre><code>bash ../envSloth.sh [OPTIONS] --mfem=$MFEM4SLOTH\n</code></pre> where <code>$MFEM4SLOTH</code> is a variable associated with the path towards the <code>MFEM</code> installation (ie <code>$HOME/MFEM4SLOTH</code> in the current description) and [OPTIONS] are: <pre><code>    --release to build SLOTH with Release compiler options \n\n    --optim to build SLOTH with Optim compiler options \n\n    --debug to build SLOTH with Debug compiler options \n\n    --coverage to build SLOTH with Coverage compiler options \n\n    --minsizerel to build with MinSizeRel compiler options \n\n    --relwithdebinfo to build with RelWithDebInfo compiler options \n\n    --external to built SLOTH with an external package\n</code></pre></li> </ul> <p>By default, <code>SLOTH</code> is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Installation/libtorch.html","title":"PyTorch C++ API","text":"<p>The following installation procedure describes how to install and link the library <code>libTorch</code> that contains C++ APIs used to load <code>PyTorch</code> models in some <code>SLOTH</code> applications.  The procedure focuses on the CPU-only <code>libTorch</code></p>"},{"location":"Started/Installation/libtorch.html#getting-libtorch","title":"Getting libTorch","text":"<p>The library <code>libTorch</code> can be downloaded either from the <code>PyTorch</code> website or by running the following instructions in a terminal:</p> <pre><code>wget https://download.pytorch.org/libtorch/nightly/cpu/libtorch-shared-with-deps-latest.zip\n\nunzip libtorch-shared-with-deps-latest.zip\n</code></pre> <p>This will result in an uncompressed folder named <code>libtorch</code> that can be linked to <code>SLOTH</code> during the configuration of the project.</p>"},{"location":"Started/Installation/libtorch.html#linking-sloth-and-libtorch","title":"Linking SLOTH and libTorch","text":"<p>To link <code>SLOTH</code> with <code>libTorch</code>, the user must load the <code>SLOTH</code> configuration file with the <code>--libtorch</code> option:</p> <pre><code>bash ../envSloth.sh --libtorch=$LIBTORCH_PATH\n</code></pre> <p>where <code>LIBTORCH_PATH</code> is an environment variable containing the path toward the <code>libtorch</code> folder previously uncompressed.</p>"},{"location":"Started/Installation/linux.html","title":"On Linux with Spack","text":"<p>A straightforward way to install MFEM is to use spack.</p> <p>Installing spack</p> <p>To install spack on Linux, the first step consists in cloning and loading it into a <code>$SPACK</code> directory (see spack for more details.)</p> <p>Assuming <code>spack</code> well installed into the <code>$SPACK</code> directory, the following command enables to install MFEM with right additional packages:</p> <pre><code>source $SPACK/share/spack/setup-env.sh\n\nspack install mfem+mpi+suite-sparse+sundials+superlu-dist+miniapps\n</code></pre> <p>Installing a given version of MFEM</p> <p>The user is free to install different version of MFEM.  By default, the last released is considered. otherwise, \"@version\" must be added at the end of the <code>spack</code> command.</p> <p>Once MFEM is installed, priori to compile SLOTH, MFEM must be loaded and several environment variables must be defined:</p> <pre><code>   spack load mfem\n\n   export HYPRE_DIR=$(spack location -i hypre)\n\n   export MPI_DIR=$(spack location -i mpi)\n\n   export METIS_DIR=$(spack location -i metis)\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the SLOTH repository.  The use of this file is recommended to load the MFEM environment before compilling SLOTH.</p> <ul> <li>Load the SLOTH configuration file: <pre><code>bash ../envSloth.sh [OPTIONS] \n</code></pre> where [OPTIONS] are: <pre><code>    --release to build with Release compiler options \n\n    --optim to build with Optim compiler options \n\n    --debug to build with Debug compiler options \n\n    --coverage to build with Coverage compiler options \n\n    --minsizerel to build with MinSizeRel compiler options \n\n    --relwithdebinfo to build with RelWithDebInfo compiler options \n\n    --external to built SLOTH with an external package\n</code></pre></li> </ul> <p>By default, SLOTH is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Installation/mac.html","title":"On MacOS with Homebrew","text":"<p>Following the MFEM website, the simplest way to install MFEM on MacOS consists in using the package manager Homebrew (see https://brew.sh for more details):</p> <pre><code>brew install mfem\n</code></pre> <p>Installing a given version of MFEM</p> <p>By default, this MFEM installation depends on hypre, metis, openblas, suite-sparse.</p> <p>It is possible rebuild MFEM with additional dependencies (see https://formulae.brew.sh/formula/mfem#default for more details).    To do this,  </p> <ul> <li>Get the .rb file : run <code>brew edit mfem</code> to open the default rb file or get it from Github</li> <li>Add your dependencies with <code>depends_on</code> directive. Here, let us consider the <code>petsc</code> dependency:</li> </ul> <pre><code>depends_on \"cmake\" =&gt; :build\ndepends_on \"hypre\"       \ndepends_on \"metis\"       \ndepends_on \"openblas\"\ndepends_on \"suite-sparse\"\ndepends_on \"petsc\"\n</code></pre> <ul> <li>Save the file in the directory and run the following command:</li> </ul> <pre><code>brew install --formula mfem.rb\n</code></pre> <p>Installation with petsc can be checked by editing once again the mfem.rb file. petsc must be mentioned as default dependency. </p> <p>Each dependency can be installed easily using homebrew. </p> <p>Once MFEM is installed, priori to compile SLOTH several environment variables must be defined:</p> <pre><code>export MFEM_DIR=$(echo `brew --prefix mfem`)\n\nexport MPI_DIR=$(echo `brew --prefix open-mpi`)\n\nexport HYPRE_DIR=$(echo `brew --prefix hypre`)\n\nexport METIS_DIR=$(echo `brew --prefix metis`)\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the SLOTH repository.  The use of this file is recommended to load the MFEM environment before compilling SLOTH.</p> <ul> <li>Load the SLOTH configuration file: <pre><code>source ../envSloth.sh [OPTIONS] \n</code></pre> where [OPTIONS] are: <pre><code>    --release to build with Release compiler options \n\n    --optim to build with Optim compiler options \n\n    --debug to build with Debug compiler options \n\n    --coverage to build with Coverage compiler options \n\n    --minsizerel to build with MinSizeRel compiler options \n\n    --relwithdebinfo to build with RelWithDebInfo compiler options \n\n    --external to built SLOTH with an external package\n</code></pre></li> </ul> <p>By default, SLOTH is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Installation/sources.html","title":"On Linux from source files","text":"<p>The following installation procedure describes how to install <code>SLOTH</code> from source files. </p> <p>It is assumed that the user has a Unix environment with a recent GCC compiler (C++20 compatible) and MPI libraries. Obviously, Git is also needed to clone source files.</p> <p>The following procedure is mainly based on the installation procedure of a parallel MPI version of <code>MFEM</code>.  Only the installation of SuiteSparse will be added.</p>"},{"location":"Started/Installation/sources.html#getting-source-files","title":"Getting source files","text":"<p>The first step consists in cloning <code>MFEM</code>, <code>METIS</code>, <code>HYPRE</code> and <code>SuiteSparse</code>.</p> <p>Clone of the default branch</p> <ul> <li>The current installation procedure assumes that the clone of the source files is based on the default branch of each repository.</li> <li>Users are free to consider different branches for their installation.</li> </ul> <p>All sources are collected in a global directory called <code>MFEM4SLOTH</code>. </p> <pre><code>cd $HOME\nmkdir MFEM4SLOTH\ncd MFEM4SLOTH\n</code></pre>"},{"location":"Started/Installation/sources.html#mfem","title":"MFEM","text":"<p>MFEM's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/mfem/mfem.git\n</code></pre>"},{"location":"Started/Installation/sources.html#hypre","title":"HYPRE","text":"<p>HYPRE's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/hypre-space/hypre.git\n</code></pre>"},{"location":"Started/Installation/sources.html#metis","title":"METIS","text":"<p>METIS's source files are obtained by running the following commands:</p> <pre><code>git clone https://github.com/mfem/tpls.git\nmv tpls/metis-4.0.3.tar.gz .\ntar -zxvf metis-4.0.3.tar.gz\nrm -fr metis-4.0.3.tar.gz tpls\n</code></pre>"},{"location":"Started/Installation/sources.html#suitesparse","title":"SuiteSparse","text":"<p>SuiteSparse's source files are obtained by running the following command:</p> <pre><code>git clone https://github.com/DrTimothyAldenDavis/SuiteSparse.git\n</code></pre>"},{"location":"Started/Installation/sources.html#building-dependencies","title":"Building dependencies","text":"<p>The second step consists in building <code>METIS</code>, <code>HYPRE</code> and <code>SuiteSparse</code>.</p>"},{"location":"Started/Installation/sources.html#metis_1","title":"METIS","text":"<p>To build <code>METIS</code>, the following command must be run:</p> <pre><code>cd metis-4.0.3\nmake OPTFLAGS=-Wno-error=implicit-function-declaration\ncd ..\nln -s metis-4.0.3 metis-4.0\n</code></pre>"},{"location":"Started/Installation/sources.html#hypre_1","title":"HYPRE","text":"<p>To build <code>HYPRE</code>, the following command must be run:</p> <p><pre><code>cd hypre/src\n./configure --disable-fortran\nmake -j N\ncd ../..\n</code></pre> where <code>N</code> is a user defined number of CPUs.</p>"},{"location":"Started/Installation/sources.html#suitesparse_1","title":"SuiteSparse","text":"<p>To build <code>SuiteSparse</code>, the following commands must be run:</p> <p><pre><code>cd SuiteSparse/\nmake -j N\nmake install DESTDIR=$PWD/INSTALLDIR\nmv INSTALLDIR/usr/local/lib/* lib/\nmv INSTALLDIR/usr/local/include/suitesparse/* include/\nmv INSTALLDIR/usr/local/bin/* bin/\ncd ..\n</code></pre> where <code>N</code> is a user defined number of CPUs.</p> <p>Possible errors</p> <p>Depending the Unix configuration of the user, it is possible to have errors because some dependencies are not found as, for example, <code>MFPR</code>. In that case, these missing dependencies must be installed.  For example, to install <code>MFPR</code> on Ubuntu Jammy, the following command can be run: <pre><code>sudo apt-get install libmpfr-dev\n</code></pre></p>"},{"location":"Started/Installation/sources.html#building-mfem-with-dependencies","title":"Building MFEM with dependencies","text":"<p>Here, we assume that all dependencies are well built according to the previous directives.  At this stage, <code>MFEM</code> can be installed by running the following commands:</p> <pre><code>cd mfem\nmake -j N parallel MFEM_USE_SUITESPARSE=YES \nmake install PREFIX=INSTALLDIR\ncd ..\n</code></pre>"},{"location":"Started/Installation/sources.html#sloth-compilation","title":"SLOTH compilation","text":"<p>Once <code>MFEM</code> is installed, priori to compile <code>SLOTH</code>, several environment variables must be defined:</p> <pre><code>    export MFEM_DIR=\"$MFEM4SLOTH/mfem/INSTALLDIR/\"\n    export HYPRE_DIR=\"$MFEM4SLOTH/hypre/src/hypre/\"\n    export METIS_DIR=\"$MFEM4SLOTH/metis-4.0/\"\n    export SuiteSparse_DIR=\"$MFEM4SLOTH/SuiteSparse/\"\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the <code>SLOTH</code> repository.  The use of this file is recommended to load the <code>MFEM</code> environment before compilling <code>SLOTH</code>.</p> <ul> <li>Load the <code>SLOTH</code> configuration file: <pre><code>bash ../envSloth.sh [OPTIONS] --mfem=$MFEM4SLOTH\n</code></pre> where <code>$MFEM4SLOTH</code> is a variable associated with the path towards the <code>MFEM</code> installation (ie <code>$HOME/MFEM4SLOTH</code> in the current description) and [OPTIONS] are: <pre><code>    --release to build SLOTH with Release compiler options \n\n    --optim to build SLOTH with Optim compiler options \n\n    --debug to build SLOTH with Debug compiler options \n\n    --minsizerel to build with MinSizeRel compiler options \n\n    --relwithdebinfo to build with RelWithDebInfo compiler options \n\n    --coverage to build SLOTH with Coverage compiler options \n\n    --external to built SLOTH with an external package\n</code></pre></li> </ul> <p>By default, <code>SLOTH</code> is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Quality/quality.html","title":"Code quality","text":""},{"location":"Started/Quality/quality.html#static-code-analyis","title":"Static code analyis","text":"<p>CppLint is used to check code quality according to Google's C++ style guide.</p> <p>CppLint is a static code checker that can be easily installed from PyPI:</p> <pre><code>pip install cpplint\n</code></pre> <p>The options considered for static code analysis are:</p> <ul> <li><code>linelength=100</code> to set the maximum allowed line length for your code</li> <li><code>filter=-runtime/references,-build/header_guard,-runtime/string</code></li> </ul> <p>These options are placed in the file CPPLINT.cfg, available in the root of the SLOTH repository.</p> <p>In practice, after loading the SLOTH environement file, using the CMake target  <code>lint</code> enables to run the static code analysis:</p> <pre><code>make lint\n</code></pre>"},{"location":"Started/Quality/quality.html#code-coverage-analysis","title":"Code coverage analysis","text":"<p>Performing code coverage analysis consists of three simple steps:</p> <ul> <li>Compilling SLOTH in coverage mode <pre><code>mkdir build\ncd build\nsource ../envSloth.sh --coverage\nmake -j N\n</code></pre></li> <li>Running the tests (here, for example, all cases stored in the folder <code>tests</code>): <pre><code>ctest -j N\n</code></pre></li> <li>Running the CMake target <code>cc</code> to generate the code coverage analysis within the Coverage folder: <pre><code>make cc\n</code></pre></li> </ul> <p>Code quality control before contributing</p> <p>It is a prerequisite that both static code analysis and code coverage analysis are conducted prior to the incorporation of new functionalities in SLOTH. The results of these two analyses should get better or at least stay the same.</p>"}]}