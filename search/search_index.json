{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SLOTH","text":"The multiphase-field multicomponent framework of the PLEIADES platform     based on MFEM  <ul> <li> <p>Features</p> <ul> <li>Phase-field modelling</li> <li>Finite Element, AMR</li> <li>Unsteady, nonlinear, coupled problems</li> <li>Massively parallel MPI implementation </li> <li>Calphad-informed phase-field</li> </ul> </li> <li> <p>News</p> <ul> <li>SLOTH at NuMat Conference [10/24]</li> </ul> </li> <li> <p>Latest Release</p> <p>(Coming  soon)</p> </li> <li> <p>Contact</p> <p>Use the Github issue tracker to report bugs or comments. </p> <p>See the About page for contact and license information.</p> </li> </ul>"},{"location":"physical_description.html","title":"Physical description","text":""},{"location":"physical_description.html#welcome-to-the-documentation-of-the-phase-field-solver-based-on-mfem","title":"Welcome to the documentation of the Phase-Field Solver based on MFEM","text":""},{"location":"About/index.html","title":"About the SLOTH project","text":""},{"location":"About/index.html#project-summary","title":"Project summary","text":"<p>Phase-field methods represent a versatile and effective approach to modelling the spatiotemporal evolution of complex physical systems that exhibit significant heterogeneities, such as phase transitions, coalescence, and cracking. These methods have found extensive application in the field of materials science, including in the modelling of the behaviour of nuclear fuels. </p> <p>The phase-field approach has also been employed in recent studies conducted with the multiphysics computational tools of the PLEIADES platform<sup>1</sup>. Broadly speaking, the <code>PLEIADES</code>/Fuel Performance Codes<sup>2</sup><sup>3</sup> aim at providing a state-of-the-art multiphysics multiscale description of the fuel under irradiated conditions. The inclusion of an advanced multiphysics and multiscale modelling such as phase-field, is a logical step forward. Consequently, the CEA is developing SLOTH, a multiphase-field multicomponent framework, dedicated to the study of fuel behaviour at different scales of description, from nominal operating conditions to severe accident conditions. </p> <p><code>PLEIADES/SLOTH</code> is developed at CEA under LPGL license (Version 3). It is based on the the <code>MFEM</code> Finite Element library<sup>4</sup>, which already includes the main features to have a robust, flexible and massively parallel implementation of the solution algorithms.</p> <p>Incipient melting in a pellet fragment under an ad-hoc temperature dependent enthalpy of melting</p> <p>Polycristalline microstructure with 30 grains</p> <p>Spinodal decomposition</p>"},{"location":"About/index.html#contributors","title":"Contributors","text":"<ul> <li> <p>Modelling &amp; Development Team</p> <ul> <li>Cl\u00e9ment Intro\u00efni (Phase-Field, Computer Science, Material Science)</li> <li>Rapha\u00ebl Prat (Computer Science, HPC)</li> </ul> </li> <li> <p>Students Team</p> <ul> <li>Alessandro Scapini (PhD 2024-2027)</li> <li>Cl\u00e9ment Plumecocq (PhD 2023-2026)</li> <li>Mouad Bakhkakh (Master 2024)</li> <li>Etienne Delobre (Master 2023)</li> </ul> </li> </ul> <ol> <li> <p>St\u00e9phane Bernaud, Isabelle Rami\u00e8re, Guillaume Latu, and Bruno Michel. Pleiades: a numerical framework dedicated to the multiphysics and multiscale nuclear fuel behavior simulation. Annals of Nuclear Energy, 205:110577, 2024.\u00a0\u21a9</p> </li> <li> <p>C Intro\u00efni, I Rami\u00e8re, J Sercombe, B Michel, T Helfer, and J Fauque. Alcyone: the fuel performance code of the pleiades platform dedicated to pwr fuel rods behavior. Annals of Nuclear Energy, 207:110711, 2024.\u00a0\u21a9</p> </li> <li> <p>Marc Lainet, Bruno Michel, Jean-Christophe Dumas, Michel Pelletier, and Isabelle Rami\u00e8re. Germinal, a fuel performance code of the pleiades platform to simulate the in-pile behaviour of mixed oxide fuel pins for sodium-cooled fast reactors. Journal of Nuclear Materials, 516:30\u201353, 2019.\u00a0\u21a9</p> </li> <li> <p>Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell, Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron Fisher, Tzanio Kolev, and others. Mfem: a modular finite element methods library. Computers &amp; Mathematics with Applications, 81:42\u201374, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Applications/index.html","title":"Coming soon","text":""},{"location":"Documentation/Code/index.html","title":"Coming soon","text":""},{"location":"Documentation/Physical/index.html","title":"Coming soon","text":""},{"location":"Documentation/Physical/index.html#introduction-to-the-phase-field-modelling","title":"Introduction to the phase-field modelling","text":""},{"location":"Documentation/Physical/index.html#cahn-hilliard-model","title":"Cahn-Hilliard model","text":""},{"location":"Documentation/Physical/index.html#allen-cahn-model","title":"Allen-Cahn model","text":""},{"location":"Documentation/Physical/model1.html","title":"Model1","text":""},{"location":"Documentation/Physical/model1.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/Physical/model1.html#section-model-1","title":"section model 1","text":""},{"location":"Documentation/Physical/model2.html","title":"Model2","text":""},{"location":"Documentation/Physical/model2.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/Physical/model2.html#section-model-1","title":"section model 1","text":""},{"location":"Documentation/Physical/model3.html","title":"Model3","text":""},{"location":"Documentation/Physical/model3.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/Physical/model3.html#section-model-1","title":"section model 1","text":""},{"location":"Documentation/User/index.html","title":"Coming soon","text":""},{"location":"Documentation/User/model1.html","title":"Model1","text":""},{"location":"Documentation/User/model1.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/User/model1.html#section-model-1","title":"section model 1","text":""},{"location":"Documentation/User/model2.html","title":"Model2","text":""},{"location":"Documentation/User/model2.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/User/model2.html#section-model-1","title":"section model 1","text":""},{"location":"Documentation/User/model3.html","title":"Model3","text":""},{"location":"Documentation/User/model3.html#model-1","title":"Model 1","text":"<p>this is the modle 1</p>"},{"location":"Documentation/User/model3.html#section-model-1","title":"section model 1","text":""},{"location":"References/index.html","title":"Coming soon","text":""},{"location":"Started/index.html","title":"A Step-By-Step Guide","text":"<p>This page provides users with comprehensive information on installing and using SLOTH, making it easier to develop custom applications. </p> <ul> <li>Installation guide </li> <li>Examples</li> <li>Code quality</li> <li>How to build an application</li> </ul> <p>Before following these instructions, users are required to clone the code of SLOTH, which is available for download from Github. </p> <pre><code>git clone https://github.com/Collab4Sloth/SLOTH.git \n</code></pre> <p>SLOTH project</p> <p>Scanning this QR code will direct users to other associated repositories: </p> DocumentationGalleryStudies <p>This repository is dedicted to the documentation of the project including the user manual and the physical description of models implemented in SLOTH.</p> <pre><code>git clone https://github.com/Collab4Sloth/Documentation.git\n</code></pre> <p>This repository is the Hall of Fame of simulations performed with SLOTH.</p> <pre><code>git clone https://github.com/Collab4Sloth/Gallery.git\n</code></pre> <p>Please note that this repository is still under construction. It will contain all the information from public studies conducted with SLOTH. </p> <pre><code>git clone https://github.com/Collab4Sloth/Studies.git\n</code></pre>"},{"location":"Started/Examples/index.html","title":"Coming soon","text":""},{"location":"Started/HowTo/index.html","title":"Index","text":""},{"location":"Started/HowTo/index.html#coming-soon","title":"Coming soon","text":""},{"location":"Started/Installation/index.html","title":"Installation guide","text":"<p><code>SLOTH</code> is written in <code>C++17</code>. It can be built under Linux and MacOS using <code>CMake</code>.  The main prerequisite is the <code>MFEM</code> Finite Element library developed in C++ by LLNL<sup>1</sup>.</p> <p><code>MFEM</code> can be installed in several ways but the use of <code>spack</code> on Linux and <code>Homebrew</code>on MacOS is recommended for sake of simplicity.</p> <p>Installing <code>SLOTH</code> therefore consists of first installing <code>MFEM</code> and compiling <code>SLOTH</code>.  The basic procedure is then provided for the Linux platform and the MacOs platform, but also for supercomputers where <code>SLOTH</code> is intended to be used.</p> <ol> <li> <p>Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell, Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron Fisher, Tzanio Kolev, and others. Mfem: a modular finite element methods library. Computers &amp; Mathematics with Applications, 81:42\u201374, 2021.\u00a0\u21a9</p> </li> </ol>"},{"location":"Started/Installation/cluster.html","title":"Cluster","text":""},{"location":"Started/Installation/cluster.html#installing-sloth-on-supercomputers-without-internet-access","title":"Installing SLOTH On Supercomputers Without Internet Access","text":"<p>This guide provides detailed steps to install SLOTH on a supercomputer without internet access using provided scripts. It includes using Spack for package management and compiling dependencies required by SLOTH.</p> <p>Installing SLOTH on a supercomputer without internet access involves preparing the environment, downloading necessary components, creating a local Spack mirror, and building SLOTH with all dependencies.</p>"},{"location":"Started/Installation/cluster.html#use-and-adapt-scripts","title":"Use And Adapt Scripts","text":"<p>The installation is performed in two main parts using the scripts provided below:</p> <ol> <li><code>sloth-topaze-part1.sh</code>: Prepares the environment and creates an archive of necessary components.</li> <li><code>sloth-topaze-part2.sh</code>: Sets up Spack and compiles SLOTH on the target supercomputer.</li> </ol> <p>Make sure to adapt the environment variables in the scripts (e.g., <code>MY_LOG</code>, <code>DEST_DIR</code>) to your specific user settings.</p> <p>On your local machine:</p> <pre><code>source sloth-topaze-part1.sh\n</code></pre> <p>On your distant machine (Topaze in our example)</p> <pre><code>sloth-topaze-part2.sh\n</code></pre>"},{"location":"Started/Installation/cluster.html#part-1-preparing-the-environment-sloth-topaze-part1sh","title":"Part 1: Preparing the Environment (<code>sloth-topaze-part1.sh</code>)","text":"<p>This script is designed to be run on a local machine with internet access. It sets up the environment, clones necessary repositories, prepares Spack, and packages everything into an archive for transfer to the supercomputer.</p>"},{"location":"Started/Installation/cluster.html#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<ol> <li>Define Root and Working Directories: <pre><code>export ROOT_DIR=$PWD\nmkdir -p sloth-topaze-dir &amp;&amp; cd sloth-topaze-dir\nexport WORK_DIR=$ROOT_DIR/sloth-topaze-dir\nexport MY_LOG=your_login      # Replace with your Topaze login\nexport DEST_DIR=/path/to/destination # Replace with your destination directory\n</code></pre></li> <li><code>ROOT_DIR</code> is set to the current directory.</li> <li>Creates a subdirectory <code>sloth-topaze-dir</code> where all operations will occur.</li> <li><code>WORK_DIR</code> is set to the path of <code>sloth-topaze-dir</code>.</li> <li> <p><code>MY_LOG</code> and <code>DEST_DIR</code> are placeholders for your supercomputer login and destination directory. You need to replace these with your actual login and path on the supercomputer.</p> </li> <li> <p>Clone Spack Repository: <pre><code>echo \"Getting Spack ...\"\nif [ ! -d \"spack\" ]; then\n    git clone https://github.com/spack/spack.git\nfi\nexport SPACK_ROOT=$PWD/spack\nrm -r ~/.spack\nsource ${SPACK_ROOT}/share/spack/setup-env.sh\n</code></pre></p> </li> <li>Clones Spack from GitHub.</li> <li>Sets <code>SPACK_ROOT</code> to the path of the cloned Spack directory.</li> <li>Removes any existing <code>.spack</code> configuration to ensure a clean setup.</li> <li> <p>Sources the Spack environment to set up paths and commands for use.</p> </li> <li> <p>Clone SLOTH Repository: <pre><code>echo \"Getting PLEIADES/SLOTH ...\"\nif [ ! -d \"sloth\" ]; then\n    git clone [https://www-git-cad.intra.cea.fr/DEC/collaboratif/ci230846/DEV_PROJECT/sloth.git](https://github.com/Collab4Sloth/SLOTH.git)\nfi\n</code></pre></p> </li> <li> <p>Similar to Spack, this step clones the SLOTH repository if it doesn't already exist in the working directory.</p> </li> <li> <p>Create a Spack Bootstrap Mirror: <pre><code>spack bootstrap mirror --binary-packages my_bootstrap\n</code></pre></p> </li> <li> <p>Creates a bootstrap mirror that includes binary packages of the basic build tools that Spack needs to work offline.</p> </li> <li> <p>Create a Specific Spack Mirror for Dependencies: <pre><code>spack mirror create -d mirror-mfem -D gcc@11.2.0 mfem+mpi+debug+openmp+petsc+strumpack+suite-sparse+sundials+superlu-dist%gcc@11.2.0\n</code></pre></p> </li> <li>Creates a mirror named <code>mirror-mfem</code> for all specified dependencies (<code>mfem</code>, <code>petsc</code>, etc.), ensuring that Spack can access these packages without internet access on the supercomputer.</li> <li> <p>You can add extra packages here.</p> </li> <li> <p>Package and Transfer Files: <pre><code>cd $ROOT_DIR\ntar cvf archive.tar.gz sloth-topaze-dir/\nscp archive.tar.gz $MY_LOG@topaze.ccc.cea.fr:$DEST_DIR/\n</code></pre></p> </li> <li>Archives the entire <code>sloth-topaze-dir</code> directory into <code>archive.tar.gz</code>.</li> <li>Uses <code>scp</code> to securely copy this archive to the specified destination directory on the supercomputer. Replace <code>topaze.ccc.cea.fr</code> with the appropriate hostname if needed.</li> </ol>"},{"location":"Started/Installation/cluster.html#part-2-setting-up-and-building-sloth-sloth-topaze-part2sh","title":"Part 2: Setting Up and Building SLOTH (<code>sloth-topaze-part2.sh</code>)","text":"<p>This script is run on the supercomputer. It unpacks the archive, sets up the Spack environment, configures Spack to work offline, and builds SLOTH with all required dependencies.</p>"},{"location":"Started/Installation/cluster.html#step-by-step-breakdown_1","title":"Step-by-Step Breakdown","text":"<ol> <li>Define Directories: <pre><code>export DEST_DIR=$PWD\nexport WORK_DIR=$DEST_DIR/sloth-topaze-dir\n</code></pre></li> <li><code>DEST_DIR</code> is set to the current working directory (where the archive was transferred).</li> <li> <p><code>WORK_DIR</code> points to the <code>sloth-topaze-dir</code> directory inside <code>DEST_DIR</code>.</p> </li> <li> <p>Clean Up and Extract the Archive: <pre><code>rm -r ~/.spack\ncd $DEST_DIR\ntar xvf archive.tar.gz\ncd $WORK_DIR\n</code></pre></p> </li> <li>Removes any existing Spack configuration (<code>~/.spack</code>) to ensure a fresh environment setup.</li> <li> <p>Extracts the archive (<code>archive.tar.gz</code>) containing all previously prepared files.</p> </li> <li> <p>Set Up Spack Environment: <pre><code>source $WORK_DIR/spack/share/spack/setup-env.sh\nspack bootstrap reset -y\nspack bootstrap add --scope=site --trust local-binaries $PWD/my_bootstrap/metadata/binaries/\nspack bootstrap disable --scope=site github-actions-v0.5\nspack bootstrap disable --scope=site github-actions-v0.4\nspack bootstrap disable --scope=site spack-install\nspack bootstrap root $PWD/spack/bootstrap\nspack bootstrap now\nspack bootstrap status\n</code></pre></p> </li> <li>Sources the Spack environment to set up the paths and commands.</li> <li>Resets Spack\u2019s bootstrap configuration and adds the local bootstrap mirror (<code>my_bootstrap</code>) created earlier, ensuring all dependencies are fetched locally.</li> <li>Disables unnecessary bootstrap sources (<code>github-actions-v0.5</code>, etc.) to avoid any attempt to connect online.</li> <li> <p>Sets the root path for Spack\u2019s bootstrap environment and checks the status.</p> </li> <li> <p>Set Compiler and Environment Variables: <pre><code>export CC='gcc'\nexport CXX='g++'\nexport FC='mpifort'\nexport OMPI_CC='gcc'\nexport OMPI_CXX='g++'\nexport OMPI_FC='gfortran'\n</code></pre></p> </li> <li>Specifies compilers for C, C++, and Fortran, ensuring the correct toolchain is used during the build.</li> <li> <p>Sets OpenMPI environment variables to link the compilers correctly.</p> </li> <li> <p>Load Required Modules and Add Spack Mirror: <pre><code>module load gnu/11.2.0 mpi cmake/3.29.6 \nspack mirror add SLOTH $WORK_DIR/mirror-mfem/\nspack compiler find\nspack external find openmpi\nspack external find cmake\nspack external find openssh\n</code></pre></p> </li> <li>Loads necessary modules (<code>gnu</code>, <code>mpi</code>, <code>cmake</code>) to provide the required tools and compilers.</li> <li>Adds the previously created Spack mirror (<code>mirror-mfem</code>) so that dependencies are fetched from the local mirror instead of the internet.</li> <li> <p>Detects and registers available compilers and external software (e.g., <code>openmpi</code>, <code>cmake</code>, <code>openssh</code>) within Spack.</p> </li> <li> <p>Install Dependencies and Build SLOTH: <pre><code>spack install gcc@11.2.0 mfem+mpi+debug+openmp+petsc+strumpack+suite-sparse+sundials+superlu-dist%gcc@11.2.0\ncd $WORK_DIR/sloth\nmkdir build &amp;&amp; cd build\nspack load mfem\nspack load metis\nexport HYPRE_DIR=`spack location -i hypre`\nexport MPI_DIR=`spack location -i mpi`\nexport METIS_DIR=`spack location -i metis`\n\ncmake .. -DMFEM_USE_PETSC=ON -DPETSC_DIR=${PETSC_DIR} -DPETSC_ARCH=\"\" -DPETSC_INCLUDES=${PETSC_DIR}/include -DPETSC_LIBRARIES=${PETSC_DIR}/lib -DPETSC_EXECUTABLE_RUNS=${PETSC_DIR}/bin\nmake -j 10\nctest\n</code></pre></p> </li> <li>Installs GCC and other specified dependencies from the local mirror without accessing the internet.</li> <li>Sets up the build directory within the SLOTH repository (<code>build</code>).</li> <li>Loads required dependencies (<code>mfem</code>, <code>metis</code>) to ensure they are available for the build process.</li> <li>Sets environment variables to locate specific dependency installations.</li> <li>Configures SLOTH with <code>cmake</code>, pointing to relevant dependencies (<code>PETSC</code>, etc.), and builds the software using <code>make</code>.</li> <li>Runs tests with <code>ctest</code> to verify the build.</li> </ol>"},{"location":"Started/Installation/cluster.html#run-your-simulation-on-topaze","title":"Run Your Simulation On Topaze","text":"<p>Script example of a simulation running on milan partition over 8192 mpi processes with a duration limit of about 24 hours:</p> <pre><code>#!/bin/bash\n#MSUB -r sloth_big_run\n#MSUB -n 8192\n#MSUB -c 1\n#MSUB -T 86000\n#MSUB -m scratch\n#MSUB -o sloth_big_run_%I.o\n#MSUB -e sloth_big_run_%I.e\n#MSUB -q milan\n\nset -x\nexport OMP_NUM_THREADS=1\nccc_mprun ./test3D\n</code></pre>"},{"location":"Started/Installation/linux.html","title":"On Linux","text":"<p>A straightforward way to install MFEM is to use spack.</p> <p>Installing spack</p> <p>To install spack on Linux, the first step consists in cloning and loading it into a <code>$SPACK</code> directory (see spack for more details.)</p> <p>Assuming <code>spack</code> well installed into the <code>$SPACK</code> directory, the following command enables to install MFEM with right additional packages:</p> <pre><code>$SPACK/share/spack/setup-env.sh\n\nspack install mfem+mpi+suite-sparse+sundials+superlu-dist\n</code></pre> <p>Installing a given version of MFEM</p> <p>The user is free to install different version of MFEM.  By default, the last released is considered. otherwise, \"@version\" must be added at the end of the <code>spack</code> command.</p> <p>Once MFEM is installed, priori to compile SLOTH, MFEM must be loaded and several environment variables must be defined:</p> <pre><code>   spack load mfem\n\n   export HYPRE_DIR=$(spack location -i hypre)\n\n   export MPI_DIR=$(spack location -i mpi)\n\n   export METIS_DIR=$(spack location -i metis)\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the SLOTH repository.  The use of this file is recommended to load the MFEM environment before compilling SLOTH</p> <ul> <li>Load the SLOTH configuration file: <pre><code>source ../envSloth.sh [OPTIONS] \n</code></pre> where [OPTIONS] are: <pre><code>    --release to build with Release compiler options \n\n    --optim to build with Optim compiler options \n\n    --debug to build with Debug compiler options \n\n    --coverage to build with Coverage compiler options \n\n    --clean to remove previous build if it exists \n</code></pre></li> </ul> <p>By default, SLOTH is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Installation/mac.html","title":"On MacOS","text":"<p>Following the MFEM website, the simplest way to install MFEM on MacOS consists in using the package manager Homebrew (see https://brew.sh for more details):</p> <pre><code>brew install mfem\n</code></pre> <p>Installing a given version of MFEM</p> <p>By default, this MFEM installation depends on hypre, metis, openblas, suite-sparse.</p> <p>It is possible rebuild MFEM with additional dependencies (see https://formulae.brew.sh/formula/mfem#default for more details).    To do this,  </p> <ul> <li>Get the .rb file : run <code>brew edit mfem</code> to open the default rb file or get it from Github</li> <li>Add your dependencies with <code>depends_on</code> directive. Here, let us consider the <code>petsc</code> dependency:</li> </ul> <pre><code>depends_on \"cmake\" =&gt; :build\ndepends_on \"hypre\"       \ndepends_on \"metis\"       \ndepends_on \"openblas\"\ndepends_on \"suite-sparse\"\ndepends_on \"petsc\"\n</code></pre> <ul> <li>Save the file in the directory and run the following command:</li> </ul> <pre><code>brew install --formula mfem.rb\n</code></pre> <p>Installation with petsc can be checked by editing once again the mfem.rb file. petsc must be mentioned as default dependency. </p> <p>Each dependency can be installed easily using homebrew. </p> <p>Once MFEM is installed, priori to compile SLOTH several environment variables must be defined:</p> <pre><code>export MFEM_DIR=$(echo `brew --prefix mfem`)\n\nexport MPI_DIR=$(echo `brew --prefix open-mpi`)\n\nexport HYPRE_DIR=$(echo `brew --prefix hypre`)\n\nexport METIS_DIR=$(echo `brew --prefix metis`)\n</code></pre> <p>On the use of the  <code>envSloth.sh</code> configuration file</p> <p>These definitions are written into the configuration file <code>envSloth.sh</code> located in the root directory of the SLOTH repository.  The use of this file is recommended to load the MFEM environment before compilling SLOTH</p> <ul> <li>Load the SLOTH configuration file: <pre><code>source ../envSloth.sh [OPTIONS] \n</code></pre> where [OPTIONS] are: <pre><code>    --release to build with Release compiler options \n\n    --optim to build with Optim compiler options \n\n    --debug to build with Debug compiler options \n\n    --coverage to build with Coverage compiler options \n\n    --clean to remove previous build if it exists \n</code></pre></li> </ul> <p>By default, SLOTH is built with release compiler options.</p> <ul> <li>Finally, compile  <pre><code>make -j N \n</code></pre> with N the number of jobs.</li> </ul>"},{"location":"Started/Quality/quality.html","title":"Code quality","text":""},{"location":"Started/Quality/quality.html#static-code-analyis","title":"Static code analyis","text":"<p>CppLint is used to check code quality according to Google's C++ style guide.</p> <p>CppLint is a static code checker that can be easily installed from PyPI:</p> <pre><code>pip install cpplint\n</code></pre> <p>The options considered for static code analysis are:</p> <ul> <li><code>linelength=100</code> to set the maximum allowed line length for your code</li> <li><code>filter=-runtime/references,-build/header_guard,-runtime/string</code></li> </ul> <p>These options are placed in the file CPPLINT.cfg, available in the root of the SLOTH repository.</p> <p>In practice, after loading the SLOTH environement file, using the CMake target  <code>lint</code> enables to run the static code analysis:</p> <pre><code>make lint\n</code></pre>"},{"location":"Started/Quality/quality.html#code-coverage-analysis","title":"Code coverage analysis","text":"<p>Performing code coverage analysis consists of three simple steps:</p> <ul> <li>Compilling SLOTH in coverage mode <pre><code>mkdir build\ncd build\nsource ../envSloth.sh --coverage\nmake -j N\n</code></pre></li> <li>Running the tests (here, for example, all cases stored in the folder <code>tests</code>): <pre><code>ctest -j N\n</code></pre></li> <li>Running the CMake target <code>cc</code> to generate the code coverage analysis within the Coverage folder: <pre><code>make cc\n</code></pre></li> </ul> <p>Code quality control before contributing</p> <p>It is a prerequisite that both static code analysis and code coverage analysis are conducted prior to the incorporation of new functionalities in SLOTH. The results of these two analyses should get better or at least stay the same.</p>"}]}